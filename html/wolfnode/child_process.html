<!DOCTYPE html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>WolfScript API child_process</title>

  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="../assets/css/docs.css" rel="stylesheet" />
  <link href="../assets/css/github.css" rel="stylesheet" />
  <link href="../assets/fonts/foundation-icons.css" rel="stylesheet" />
   <script src="../assets/js/vendor/modernizr.js"></script>
</head>
<body>
  <body class="antialiased hide-extras">
    <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/web/index.html"><i class="fi-paw"></i> WolfScript.io</a></h1>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
      <li class="divider"></li>
         <li class='divider'></li>
<li><a href='../index.html' class=''>Docs</a></li>
<li class='divider'></li>
<li><a href='../wolfbuk/io/wolfscript/0.html' class=''>WolfBuk API</a></li>
<li class='divider'></li>
<li><a href='../wolfcanary/io/wolfscript/0.html' class=''>WolfCanary API</a></li>
<li class='divider'></li>
<li><a href='../wolfnode/globals.html' class=''>WolfNode</a></li>

       <li class="divider"></li>
       <li><a href='http://github.com/miningwolf/wolfscript ' class=''> <i class="fi-social-github"></i> Github</a></li>
       <li class="divider"></li>
       <li class="has-form">
       <a href="../GettingStarted.html " class="small button">Getting Started</a>
       </li>
    </ul>
  </section>
</nav>
<ul class="breadcrumbs">
<li><a href='../index.html'>Docs </a></li>
 <li><a href='../wolfnode/globals.html'>wolfnode</a></li>
<li class='current'><a href='#'>child_process</a></li>

</ul>

      <div class="row">
        <div class="large-3 medium-4 columns">
          <div class="hide-for-small">
            <div class="sidebar">
              <nav>
                <ul class="side-nav accordion" data-accordion>
                  <li class='heading'><a href='../wolfnode/globals.html' class=''>WolfNode</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/buffer.html' class=''>Core</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/assert.html' class=''>Other</a></li> 
<li><a href='../wolfnode/assert.html'>assert</a></li>
<li class='active'><a href='../wolfnode/child_process.html'>child_process</a></li>
<li><a href='../wolfnode/cluster.html'>cluster</a></li>
<li><a href='../wolfnode/debugger.html'>debugger</a></li>
<li><a href='../wolfnode/domain.html'>domain</a></li>
<li><a href='../wolfnode/os.html'>os</a></li>
<li><a href='../wolfnode/punycode.html'>punycode</a></li>
<li><a href='../wolfnode/readline.html'>readline</a></li>
<li><a href='../wolfnode/repl.html'>repl</a></li>
<li><a href='../wolfnode/string_decoder.html'>string_decoder</a></li>
<li><a href='../wolfnode/tty.html'>tty</a></li>
<li><a href='../wolfnode/vm.html'>vm</a></li>
<li><a href='../wolfnode/zlib.html'>zlib</a></li>
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/errors.html' class=''>Unknown</a></li> 
<li class='divider'></li>

                  </ul>
              </nav>
            </div>
          </div>
        </div>
        <div class="large-9 medium-8 columns">
          <section class="doc-content">
            <h1 id="child-process">Child Process</h1>
<pre><code><span class="hljs-attribute">Stability</span>: <span class="hljs-string">2 - Stable</span>
</code></pre><p>The <code>child_process</code> module provides the ability to spawn child processes in
a manner that is similar, but not identical, to <a href="http://linux.die.net/man/3/popen" target="_blank" rel="nofollow"><code>popen(3)</code></a>. This capability
is primarily provided by the <code>child_process.spawn()</code> function:</p>
<pre><code class="lang-js">const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const ls = spawn(<span class="hljs-string">'ls'</span>, [<span class="hljs-string">'-lh'</span>, <span class="hljs-string">'/usr'</span>]);

ls.stdout.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">stdout: ${data}</span>`);
});

ls.stderr.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">stderr: ${data}</span>`);
});

ls.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-params">(code)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">child process exited <span class="hljs-keyword">with</span> code ${code}</span>`);
});
</code></pre>
<p>By default, pipes for <code>stdin</code>, <code>stdout</code> and <code>stderr</code> are established between
the parent Node.js process and the spawned child. It is possible to stream data
through these pipes in a non-blocking way. <em>Note, however, that some programs
use line-buffered I/O internally. While that does not affect Node.js, it can
mean that data sent to the child process may not be immediately consumed.</em></p>
<p>The <code>child_process.spawn()</code> method spawns the child process asynchronously,
without blocking the Node.js event loop. The <code>child_process.spawnSync()</code>
function provides equivalent functionality in a synchronous manner that blocks
the event loop until the spawned process either exits or is terminated.</p>
<p>For convenience, the <code>child_process</code> module provides a handful of synchronous
and asynchronous alternatives to <a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a> and
<a href="#child_process_child_process_spawnsync_command_args_options"><code>child_process.spawnSync()</code></a>.  <em>Note that each of these alternatives are
implemented on top of <code>child_process.spawn()</code> or <code>child_process.spawnSync()</code>.</em></p>
<ul>
<li><code>child_process.exec()</code>: spawns a shell and runs a command within that shell,
passing the <code>stdout</code> and <code>stderr</code> to a callback function when complete.</li>
<li><code>child_process.execFile()</code>: similar to <code>child_process.exec()</code> except that
it spawns the command directly without first spawning a shell.</li>
<li><code>child_process.fork()</code>: spawns a new Node.js process and invokes a
specified module with an IPC communication channel established that allows
sending messages between parent and child.</li>
<li><code>child_process.execSync()</code>: a synchronous version of
<code>child_process.exec()</code> that <em>will</em> block the Node.js event loop.</li>
<li><code>child_process.execFileSync()</code>: a synchronous version of
<code>child_process.execFile()</code> that <em>will</em> block the Node.js event loop.</li>
</ul>
<p>For certain use cases, such as automating shell scripts, the
<a href="#child_process_synchronous_process_creation">synchronous counterparts</a> may be more convenient. In many cases, however,
the synchronous methods can have significant impact on performance due to
stalling the event loop while spawned processes complete.</p>
<h2 id="asynchronous-process-creation">Asynchronous Process Creation</h2>
<p>The <code>child_process.spawn()</code>, <code>child_process.fork()</code>, <code>child_process.exec()</code>,
and <code>child_process.execFile()</code> methods all follow the idiomatic asynchronous
programming pattern typical of other Node.js APIs.</p>
<p>Each of the methods returns a <a href="#child_process_child_process"><code>ChildProcess</code></a> instance. These objects
implement the Node.js <a href="events.html#events_class_events_eventemitter"><code>EventEmitter</code></a> API, allowing the parent process to
register listener functions that are called when certain events occur during
the life cycle of the child process.</p>
<p>The <code>child_process.exec()</code> and <code>child_process.execFile()</code> methods additionally
allow for an optional <code>callback</code> function to be specified that is invoked
when the child process terminates.</p>
<h3 id="spawning-bat-and-cmd-files-on-windows">Spawning <code>.bat</code> and <code>.cmd</code> files on Windows</h3>
<p>The importance of the distinction between <code>child_process.exec()</code> and
<code>child_process.execFile()</code> can vary based on platform. On Unix-type operating
systems (Unix, Linux, OSX) <code>child_process.execFile()</code> can be more efficient
because it does not spawn a shell. On Windows, however, <code>.bat</code> and <code>.cmd</code>
files are not executable on their own without a terminal, and therefore cannot
be launched using <code>child_process.execFile()</code>. When running on Windows, <code>.bat</code>
and <code>.cmd</code> files can be invoked using <code>child_process.spawn()</code> with the <code>shell</code>
option set, with <code>child_process.exec()</code>, or by spawning <code>cmd.exe</code> and passing
the <code>.bat</code> or <code>.cmd</code> file as an argument (which is what the <code>shell</code> option and
<code>child_process.exec()</code> do).</p>
<pre><code class="lang-js"><span class="hljs-regexp">//</span> On Windows Only ...
const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const bat = spawn(<span class="hljs-string">'cmd.exe'</span>, [<span class="hljs-string">'/c'</span>, <span class="hljs-string">'my.bat'</span>]);

bat.stdout.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(data);
});

bat.stderr.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(data);
});

bat.<span class="hljs-literal">on</span>(<span class="hljs-string">'exit'</span>, <span class="hljs-function"><span class="hljs-params">(code)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">Child exited <span class="hljs-keyword">with</span> code ${code}</span>`);
});

<span class="hljs-regexp">//</span> OR...
const exec = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).exec;
exec(<span class="hljs-string">'my.bat'</span>, <span class="hljs-function"><span class="hljs-params">(err, stdout, stderr)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-built_in">console</span>.log(stdout);
});
</code></pre>
<h3 id="child_process-exec-command-options-callback-">child_process.exec(command[, options][, callback])</h3>
<ul>
<li><code>command</code> {String} The command to run, with space-separated arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>encoding</code> {String} (Default: &#39;utf8&#39;)</li>
<li><code>shell</code> {String} Shell to execute the command with
(Default: &#39;/bin/sh&#39; on UNIX, &#39;cmd.exe&#39; on Windows,  The shell should
 understand the <code>-c</code> switch on UNIX or <code>/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code>cmd.exe</code>.)</li>
<li><code>timeout</code> {Number} (Default: 0)</li>
<li><code>maxBuffer</code> {Number} largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed (Default: <code>200*1024</code>)</li>
<li><code>killSignal</code> {String} (Default: &#39;SIGTERM&#39;)</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code>callback</code> {Function} called with the output when process terminates<ul>
<li><code>error</code> {Error}</li>
<li><code>stdout</code> {Buffer}</li>
<li><code>stderr</code> {Buffer}</li>
</ul>
</li>
<li>Return: {ChildProcess}</li>
</ul>
<p>Spawns a shell then executes the <code>command</code> within that shell, buffering any
generated output.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> exec = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).exec;
<span class="hljs-keyword">const</span> child = exec(<span class="hljs-string">'cat *.js bad_file | wc -l'</span>,
  (error, stdout, stderr) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`stdout: <span class="hljs-subst">${stdout}</span>`</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`stderr: <span class="hljs-subst">${stderr}</span>`</span>);
    <span class="hljs-keyword">if</span> (error !== <span class="hljs-literal">null</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`exec error: <span class="hljs-subst">${error}</span>`</span>);
    }
});
</code></pre>
<p>If a <code>callback</code> function is provided, it is called with the arguments
<code>(error, stdout, stderr)</code>. On success, <code>error</code> will be <code>null</code>.  On error,
<code>error</code> will be an instance of <a href="errors.html#errors_class_error"><code>Error</code></a>. The <code>error.code</code> property will be
the exit code of the child process while <code>error.signal</code> will be set to the
signal that terminated the process. Any exit code other than <code>0</code> is considered
to be an error.</p>
<p>The <code>options</code> argument may be passed as the second argument to customize how
the process is spawned. The default options are:</p>
<pre><code class="lang-js">{
  <span class="hljs-attribute">encoding</span>: <span class="hljs-string">'utf8'</span>,
  <span class="hljs-attribute">timeout</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attribute">maxBuffer</span>: <span class="hljs-number">200</span>*<span class="hljs-number">1024</span>,
  <span class="hljs-attribute">killSignal</span>: <span class="hljs-string">'SIGTERM'</span>,
  <span class="hljs-attribute">cwd</span>: null,
  <span class="hljs-attribute">env</span>: null
}
</code></pre>
<p>If <code>timeout</code> is greater than <code>0</code>, the parent will send the the signal
identified by the <code>killSignal</code> property (the default is <code>&#39;SIGTERM&#39;</code>) if the
child runs longer than <code>timeout</code> milliseconds.</p>
<p>The <code>maxBuffer</code> option specifies the largest amount of data (in bytes) allowed
on stdout or stderr - if this value is exceeded then the child process is
terminated.</p>
<p><em>Note: Unlike the <code>exec()</code> POSIX system call, <code>child_process.exec()</code> does not
replace the existing process and uses a shell to execute the command.</em></p>
<h3 id="child_process-execfile-file-args-options-callback-">child_process.execFile(file[, args][, options][, callback])</h3>
<ul>
<li><code>file</code> {String} The name or path of the executable file to run</li>
<li><code>args</code> {Array} List of string arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>encoding</code> {String} (Default: &#39;utf8&#39;)</li>
<li><code>timeout</code> {Number} (Default: 0)</li>
<li><code>maxBuffer</code> {Number} largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed (Default: 200*1024)</li>
<li><code>killSignal</code> {String} (Default: &#39;SIGTERM&#39;)</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li><code>callback</code> {Function} called with the output when process terminates<ul>
<li><code>error</code> {Error}</li>
<li><code>stdout</code> {Buffer}</li>
<li><code>stderr</code> {Buffer}</li>
</ul>
</li>
<li>Return: {ChildProcess}</li>
</ul>
<p>The <code>child_process.execFile()</code> function is similar to <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>
except that it does not spawn a shell. Rather, the specified executable <code>file</code>
is spawned directly as a new process making it slightly more efficient than
<a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>.</p>
<p>The same options as <code>child_process.exec()</code> are supported. Since a shell is not
spawned, behaviors such as I/O redirection and file globbing are not supported.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> execFile = require(<span class="hljs-string">'child_process'</span>).execFile;
<span class="hljs-keyword">const</span> child = execFile(<span class="hljs-string">'node'</span>, [<span class="hljs-string">'--version'</span>], (<span class="hljs-keyword">error</span>, stdout, stderr) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">error</span>;
  }
  console.log(stdout);
});
</code></pre>
<h3 id="child_process-fork-modulepath-args-options-">child_process.fork(modulePath[, args][, options])</h3>
<ul>
<li><code>modulePath</code> {String} The module to run in the child</li>
<li><code>args</code> {Array} List of string arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>execPath</code> {String} Executable used to create the child process</li>
<li><code>execArgv</code> {Array} List of string arguments passed to the executable
(Default: <code>process.execArgv</code>)</li>
<li><code>silent</code> {Boolean} If true, stdin, stdout, and stderr of the child will be
piped to the parent, otherwise they will be inherited from the parent, see
the <code>&#39;pipe&#39;</code> and <code>&#39;inherit&#39;</code> options for <a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&#39;s
<a href="#child_process_options_stdio"><code>stdio</code></a> for more details (default is false)</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>Return: {ChildProcess}</li>
</ul>
<p>The <code>child_process.fork()</code> method is a special case of
<a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a> used specifically to spawn new Node.js processes.
Like <code>child_process.spawn()</code>, a <code>ChildProcess</code> object is returned. The returned
<code>ChildProcess</code> will have an additional communication channel built-in that
allows messages to be passed back and forth between the parent and child. See
<a href="#child_process_child_send_message_sendhandle_callback"><code>ChildProcess#send()</code></a> for details.</p>
<p>It is important to keep in mind that spawned Node.js child processes are
independent of the parent with exception of the IPC communication channel
that is established between the two. Each process has it&#39;s own memory, with
their own V8 instances. Because of the additional resource allocations
required, spawning a large number of child Node.js processes is not
recommended.</p>
<p>By default, <code>child_process.fork()</code> will spawn new Node.js instances using the
<code>process.execPath</code> of the parent process. The <code>execPath</code> property in the
<code>options</code> object allows for an alternative execution path to be used.</p>
<p>Node.js processes launched with a custom <code>execPath</code> will communicate with the
parent process using the file descriptor (fd) identified using the
environment variable <code>NODE_CHANNEL_FD</code> on the child process. The input and
output on this fd is expected to be line delimited JSON objects.</p>
<p><em>Note: Unlike the <code>fork()</code> POSIX system call, <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a> does
not clone the current process.</em></p>
<h3 id="child_process-spawn-command-args-options-">child_process.spawn(command[, args][, options])</h3>
<ul>
<li><code>command</code> {String} The command to run</li>
<li><code>args</code> {Array} List of string arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>stdio</code> {Array|String} Child&#39;s stdio configuration. (See
<a href="#child_process_options_stdio"><code>options.stdio</code></a>)</li>
<li><code>detached</code> {Boolean} Prepare child to run independently of its parent
process. Specific behavior depends on the platform, see
<a href="#child_process_options_detached"><code>options.detached</code></a>)</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
<li><code>shell</code> {Boolean|String} If <code>true</code>, runs <code>command</code> inside of a shell. Uses
&#39;/bin/sh&#39; on UNIX, and &#39;cmd.exe&#39; on Windows. A different shell can be
specified as a string. The shell should understand the <code>-c</code> switch on UNIX,
or <code>/s /c</code> on Windows. Defaults to <code>false</code> (no shell).</li>
</ul>
</li>
<li>return: {ChildProcess}</li>
</ul>
<p>The <code>child_process.spawn()</code> method spawns a new process using the given
<code>command</code>, with command line arguments in <code>args</code>. If omitted, <code>args</code> defaults
to an empty array.</p>
<p>A third argument may be used to specify additional options, with these defaults:</p>
<pre><code class="lang-js"><span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">cwd</span>:<span class="hljs-value"> undefined,
  env: process.env
</span></span></span>}
</code></pre>
<p>Use <code>cwd</code> to specify the working directory from which the process is spawned.
If not given, the default is to inherit the current working directory.</p>
<p>Use <code>env</code> to specify environment variables that will be visible to the new
process, the default is <code>process.env</code>.</p>
<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the
exit code:</p>
<pre><code class="lang-js">const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const ls = spawn(<span class="hljs-string">'ls'</span>, [<span class="hljs-string">'-lh'</span>, <span class="hljs-string">'/usr'</span>]);

ls.stdout.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">stdout: ${data}</span>`);
});

ls.stderr.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">stderr: ${data}</span>`);
});

ls.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-params">(code)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">child process exited <span class="hljs-keyword">with</span> code ${code}</span>`);
});
</code></pre>
<p>Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;</p>
<pre><code class="lang-js">const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const ps = spawn(<span class="hljs-string">'ps'</span>, [<span class="hljs-string">'ax'</span>]);
const grep = spawn(<span class="hljs-string">'grep'</span>, [<span class="hljs-string">'ssh'</span>]);

ps.stdout.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  grep.stdin.write(data);
});

ps.stderr.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">ps stderr: ${data}</span>`);
});

ps.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-params">(code)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">console</span>.log(`<span class="javascript">ps process exited <span class="hljs-keyword">with</span> code ${code}</span>`);
  }
  grep.stdin.end();
});

grep.stdout.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">${data}</span>`);
});

grep.stderr.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">grep stderr: ${data}</span>`);
});

grep.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-params">(code)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">console</span>.log(`<span class="javascript">grep process exited <span class="hljs-keyword">with</span> code ${code}</span>`);
  }
});
</code></pre>
<p>Example of checking for failed exec:</p>
<pre><code class="lang-js">const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const child = spawn(<span class="hljs-string">'bad_command'</span>);

child.<span class="hljs-literal">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Failed to start child process.'</span>);
});
</code></pre>
<h4 id="options-detached">options.detached</h4>
<p>On Windows, setting <code>options.detached</code> to <code>true</code> makes it possible for the
child process to continue running after the parent exits. The child will have
its own console window. <em>Once enabled for a child process, it cannot be
disabled</em>.</p>
<p>On non-Windows platforms, if <code>options.detached</code> is set to <code>true</code>, the child
process will be made the leader of a new process group and session. Note that
child processes may continue running after the parent exits regardless of
whether they are detached or not.  See <code>setsid(2)</code> for more information.</p>
<p>By default, the parent will wait for the detached child to exit. To prevent
the parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method.
Doing so will cause the parent&#39;s event loop to not include the child in its
reference count, allowing the parent to exit independently of the child, unless
there is an established IPC channel between the child and parent.</p>
<p>Example of detaching a long-running process and redirecting its output to a
file:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> fs = require(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> spawn = require(<span class="hljs-string">'child_process'</span>).spawn;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">out</span> = fs.openSync(<span class="hljs-string">'./out.log'</span>, <span class="hljs-string">'a'</span>);
<span class="hljs-keyword">const</span> err = fs.openSync(<span class="hljs-string">'./out.log'</span>, <span class="hljs-string">'a'</span>);

<span class="hljs-keyword">const</span> child = spawn(<span class="hljs-string">'prg'</span>, [], {
 detached: <span class="hljs-keyword">true</span>,
 stdio: [ <span class="hljs-string">'ignore'</span>, <span class="hljs-keyword">out</span>, err ]
});

child.unref();
</code></pre>
<p>When using the <code>detached</code> option to start a long-running process, the process
will not stay running in the background after the parent exits unless it is
provided with a <code>stdio</code> configuration that is not connected to the parent.
If the parent&#39;s <code>stdio</code> is inherited, the child will remain attached to the
controlling terminal.</p>
<h4 id="options-stdio">options.stdio</h4>
<p>The <code>options.stdio</code> option is used to configure the pipes that are established
between the parent and child process. By default, the child&#39;s stdin, stdout,
and stderr are redirected to corresponding <code>child.stdin</code>, <code>child.stdout</code>, and
<code>child.stderr</code> streams on the <code>ChildProcess</code> object. This is equivalent to
setting the <code>options.stdio</code> equal to <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>.</p>
<p>For convenience, <code>options.stdio</code> may be one of the following strings:</p>
<ul>
<li><code>&#39;pipe&#39;</code> - equivalent to <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code> (the default)</li>
<li><code>&#39;ignore&#39;</code> - equivalent to <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>
<li><code>&#39;inherit&#39;</code> - equivalent to <code>[process.stdin, process.stdout, process.stderr]</code>
 or <code>[0,1,2]</code></li>
</ul>
<p>Otherwise, the value of <code>option.stdio</code> is an array where each index corresponds
to an fd in the child. The fds 0, 1, and 2 correspond to stdin, stdout,
and stderr, respectively. Additional fds can be specified to create additional
pipes between the parent and child. The value is one of the following:</p>
<ol>
<li><code>&#39;pipe&#39;</code> - Create a pipe between the child process and the parent process.
The parent end of the pipe is exposed to the parent as a property on the
<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for
fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout
and ChildProcess.stderr, respectively.</li>
<li><code>&#39;ipc&#39;</code> - Create an IPC channel for passing messages/file descriptors
between parent and child. A ChildProcess may have at most <em>one</em> IPC stdio
file descriptor. Setting this option enables the ChildProcess.send() method.
If the child writes JSON messages to this file descriptor, the
<code>ChildProcess.on(&#39;message&#39;)</code> event handler will be triggered in the parent.
If the child is a Node.js process, the presence of an IPC channel will enable
<code>process.send()</code>, <code>process.disconnect()</code>, <code>process.on(&#39;disconnect&#39;)</code>, and
<code>process.on(&#39;message&#39;)</code> within the child.</li>
<li><code>&#39;ignore&#39;</code> - Instructs Node.js to ignore the fd in the child. While Node.js
will always open fds 0 - 2 for the processes it spawns, setting the fd to
<code>&#39;ignore&#39;</code> will cause Node.js to open <code>/dev/null</code> and attach it to the
child&#39;s fd.</li>
<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,
file, socket, or a pipe with the child process. The stream&#39;s underlying
file descriptor is duplicated in the child process to the fd that
corresponds to the index in the <code>stdio</code> array. Note that the stream must
have an underlying descriptor (file streams do not until the <code>&#39;open&#39;</code>
event has occurred).</li>
<li>Positive integer - The integer value is interpreted as a file descriptor
that is is currently open in the parent process. It is shared with the child
process, similar to how <code>Stream</code> objects can be shared.</li>
<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other
words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the
default is <code>&#39;ignore&#39;</code>.</li>
</ol>
<p>Example:</p>
<pre><code class="lang-js">const spawn = require(<span class="hljs-string">'child_process'</span>).spawn;

<span class="hljs-comment">// Child will use parent's stdios</span>
spawn(<span class="hljs-string">'prg'</span>, [], { <span class="hljs-string">stdio:</span> <span class="hljs-string">'inherit'</span> });

<span class="hljs-comment">// Spawn child sharing only stderr</span>
spawn(<span class="hljs-string">'prg'</span>, [], { <span class="hljs-string">stdio:</span> [<span class="hljs-string">'pipe'</span>, <span class="hljs-string">'pipe'</span>, process.stderr] });

<span class="hljs-comment">// Open an extra fd=4, to interact with programs presenting a</span>
<span class="hljs-comment">// startd-style interface.</span>
spawn(<span class="hljs-string">'prg'</span>, [], { <span class="hljs-string">stdio:</span> [<span class="hljs-string">'pipe'</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'pipe'</span>] });
</code></pre>
<p><em>It is worth noting that when an IPC channel is established between the
parent and child processes, and the child is a Node.js process, the child
is launched with the IPC channel unreferenced (using <code>unref()</code>) until the
child registers an event handler for the <code>process.on(&#39;disconnected&#39;)</code> event.
This allows the child to exit normally without the process being held open
by the open IPC channel.</em></p>
<p>See also: <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a> and <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a></p>
<h2 id="synchronous-process-creation">Synchronous Process Creation</h2>
<p>The <code>child_process.spawnSync()</code>, <code>child_process.execSync()</code>, and
<code>child_process.execFileSync()</code> methods are <strong>synchronous</strong> and <strong>WILL</strong> block
the Node.js event loop, pausing execution of any additional code until the
spawned process exits.</p>
<p>Blocking calls like these are mostly useful for simplifying general purpose
scripting tasks and for simplifying the loading/processing of application
configuration at startup.</p>
<h3 id="child_process-execfilesync-file-args-options-">child_process.execFileSync(file[, args][, options])</h3>
<ul>
<li><code>file</code> {String} The name or path of the executable file to run</li>
<li><code>args</code> {Array} List of string arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>input</code> {String|Buffer} The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> {Array} Child&#39;s stdio configuration. (Default: &#39;pipe&#39;)<ul>
<li><code>stderr</code> by default will be output to the parent process&#39; stderr unless
<code>stdio</code> is specified</li>
</ul>
</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> {String} The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code>maxBuffer</code> {Number} largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> {String} The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
</ul>
</li>
<li>return: {Buffer|String} The stdout from the command</li>
</ul>
<p>The <code>child_process.execFileSync()</code> method is generally identical to
<code>child_process.execFile()</code> with the exception that the method will not return
until the child process has fully closed. When a timeout has been encountered
and <code>killSignal</code> is sent, the method won&#39;t return until the process has
completely exited. <em>Note that if the child process intercepts and handles
the <code>SIGTERM</code> signal and does not exit, the parent process will still wait
until the child process has exited.</em></p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <a href="errors.html#errors_class_error"><code>Error</code></a> object will contain the entire result from
<a href="#child_process_child_process_spawnsync_command_args_options"><code>child_process.spawnSync()</code></a></p>
<h3 id="child_process-execsync-command-options-">child_process.execSync(command[, options])</h3>
<ul>
<li><code>command</code> {String} The command to run</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>input</code> {String|Buffer} The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> {Array} Child&#39;s stdio configuration. (Default: &#39;pipe&#39;)<ul>
<li><code>stderr</code> by default will be output to the parent process&#39; stderr unless
<code>stdio</code> is specified</li>
</ul>
</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>shell</code> {String} Shell to execute the command with
(Default: &#39;/bin/sh&#39; on UNIX, &#39;cmd.exe&#39; on Windows,  The shell should
 understand the <code>-c</code> switch on UNIX or <code>/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code>cmd.exe</code>.)</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> {String} The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code>maxBuffer</code> {Number} largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> {String} The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
</ul>
</li>
<li>return: {Buffer|String} The stdout from the command</li>
</ul>
<p>The <code>child_process.execSync()</code> method is generally identical to
<code>child_process.exec()</code> with the exception that the method will not return until
the child process has fully closed. When a timeout has been encountered and
<code>killSignal</code> is sent, the method won&#39;t return until the process has completely
exited. <em>Note that if  the child process intercepts and handles the <code>SIGTERM</code>
signal and doesn&#39;t exit, the parent process will wait until the child
process has exited.</em></p>
<p>If the process times out, or has a non-zero exit code, this method <strong><em>will</em></strong>
throw.  The <a href="errors.html#errors_class_error"><code>Error</code></a> object will contain the entire result from
<a href="#child_process_child_process_spawnsync_command_args_options"><code>child_process.spawnSync()</code></a></p>
<h3 id="child_process-spawnsync-command-args-options-">child_process.spawnSync(command[, args][, options])</h3>
<ul>
<li><code>command</code> {String} The command to run</li>
<li><code>args</code> {Array} List of string arguments</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} Current working directory of the child process</li>
<li><code>input</code> {String|Buffer} The value which will be passed as stdin to the spawned process<ul>
<li>supplying this value will override <code>stdio[0]</code></li>
</ul>
</li>
<li><code>stdio</code> {Array} Child&#39;s stdio configuration.</li>
<li><code>env</code> {Object} Environment key-value pairs</li>
<li><code>uid</code> {Number} Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> {Number} Sets the group identity of the process. (See setgid(2).)</li>
<li><code>timeout</code> {Number} In milliseconds the maximum amount of time the process is allowed to run. (Default: undefined)</li>
<li><code>killSignal</code> {String} The signal value to be used when the spawned process will be killed. (Default: &#39;SIGTERM&#39;)</li>
<li><code>maxBuffer</code> {Number} largest amount of data (in bytes) allowed on stdout or
stderr - if exceeded child process is killed</li>
<li><code>encoding</code> {String} The encoding used for all stdio inputs and outputs. (Default: &#39;buffer&#39;)</li>
<li><code>shell</code> {Boolean|String} If <code>true</code>, runs <code>command</code> inside of a shell. Uses
&#39;/bin/sh&#39; on UNIX, and &#39;cmd.exe&#39; on Windows. A different shell can be
specified as a string. The shell should understand the <code>-c</code> switch on UNIX,
or <code>/s /c</code> on Windows. Defaults to <code>false</code> (no shell).</li>
</ul>
</li>
<li>return: {Object}<ul>
<li><code>pid</code> {Number} Pid of the child process</li>
<li><code>output</code> {Array} Array of results from stdio output</li>
<li><code>stdout</code> {Buffer|String} The contents of <code>output[1]</code></li>
<li><code>stderr</code> {Buffer|String} The contents of <code>output[2]</code></li>
<li><code>status</code> {Number} The exit code of the child process</li>
<li><code>signal</code> {String} The signal used to kill the child process</li>
<li><code>error</code> {Error} The error object if the child process failed or timed out</li>
</ul>
</li>
</ul>
<p>The <code>child_process.spawnSync()</code> method is generally identical to
<code>child_process.spawn()</code> with the exception that the function will not return
until the child process has fully closed. When a timeout has been encountered
and <code>killSignal</code> is sent, the method won&#39;t return until the process has
completely exited. Note that if the process intercepts and handles the
<code>SIGTERM</code> signal and doesn&#39;t exit, the parent process will wait until the child
process has exited.</p>
<h2 id="class-childprocess">Class: ChildProcess</h2>
<p>Instances of the <code>ChildProcess</code> class are <a href="events.html#events_class_events_eventemitter"><code>EventEmitters</code></a> that represent
spawned child processes.</p>
<p>Instances of <code>ChildProcess</code> are not intended to be created directly. Rather,
use the <a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>, <a href="#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>,
<a href="#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>, or <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a> methods to create
instances of <code>ChildProcess</code>.</p>
<h3 id="event-close-">Event: &#39;close&#39;</h3>
<ul>
<li><code>code</code> {Number} the exit code if the child exited on its own.</li>
<li><code>signal</code> {String} the signal by which the child process was terminated.</li>
</ul>
<p>The <code>&#39;close&#39;</code> event is emitted when the stdio streams of a child process have
been closed. This is distinct from the <code>&#39;exit&#39;</code> event, since multiple
processes might share the same stdio streams.</p>
<h3 id="event-disconnect-">Event: &#39;disconnect&#39;</h3>
<p>The <code>&#39;disconnect&#39;</code> event is emitted after calling the
<code>ChildProcess.disconnect()</code> method in the parent or child process. After
disconnecting it is no longer possible to send or receive messages, and the
<code>ChildProcess.connected</code> property is false.</p>
<h3 id="event-error-">Event:  &#39;error&#39;</h3>
<ul>
<li><code>err</code> {Error} the error.</li>
</ul>
<p>The <code>&#39;error&#39;</code> event is emitted whenever:</p>
<ol>
<li>The process could not be spawned, or</li>
<li>The process could not be killed, or</li>
<li>Sending a message to the child process failed.</li>
</ol>
<p>Note that the <code>&#39;exit&#39;</code> event may or may not fire after an error has occurred.
If you are listening to both the <code>&#39;exit&#39;</code> and <code>&#39;error&#39;</code> events, it is important
to guard against accidentally invoking handler functions multiple times.</p>
<p>See also <a href="#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> and <a href="#child_process_child_send_message_sendhandle_callback"><code>ChildProcess#send()</code></a>.</p>
<h3 id="event-exit-">Event:  &#39;exit&#39;</h3>
<ul>
<li><code>code</code> {Number} the exit code if the child exited on its own.</li>
<li><code>signal</code> {String} the signal by which the child process was terminated.</li>
</ul>
<p>The <code>&#39;exit&#39;</code> event is emitted after the child process ends. If the process
exited, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If the
process terminated due to receipt of a signal, <code>signal</code> is the string name of
the signal, otherwise <code>null</code>. One of the two will always be non-null.</p>
<p>Note that when the <code>&#39;exit&#39;</code> event is triggered, child process stdio streams
might still be open.</p>
<p>Also, note that Node.js establishes signal handlers for <code>SIGINT</code> and
<code>SIGTERM</code> and Node.js processes will not terminate immediately due to receipt
of those signals. Rather, Node.js will perform a sequence of cleanup actions
and then will re-raise the handled signal.</p>
<p>See <code>waitpid(2)</code>.</p>
<h3 id="event-message-">Event: &#39;message&#39;</h3>
<ul>
<li><code>message</code> {Object} a parsed JSON object or primitive value.</li>
<li><code>sendHandle</code> {Handle} a <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> or <a href="net.html#net_class_net_server"><code>net.Server</code></a> object, or
undefined.</li>
</ul>
<p>The <code>&#39;message&#39;</code> event is triggered when a child process uses <code>process.send()</code>
to send messages.</p>
<h3 id="child-connected">child.connected</h3>
<ul>
<li>{Boolean} Set to false after <code>.disconnect</code> is called</li>
</ul>
<p>The <code>child.connected</code> property indicates whether it is still possible to send
and receive messages from a child process. When <code>child.connected</code> is false, it
is no longer possible to send or receive messages.</p>
<h3 id="child-disconnect-">child.disconnect()</h3>
<p>Closes the IPC channel between parent and child, allowing the child to exit
gracefully once there are no other connections keeping it alive. After calling
this method the <code>child.connected</code> and <code>process.connected</code> properties in both
the parent and child (respectively) will be set to <code>false</code>, and it will be no
longer possible to pass messages between the processes.</p>
<p>The <code>&#39;disconnect&#39;</code> event will be emitted when there are no messages in the
process of being received. This will most often be triggered immediately after
calling <code>child.disconnect()</code>.</p>
<p>Note that when the child process is a Node.js instance (e.g. spawned using
<a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>), the <code>process.disconnect()</code> method can be invoked
within the child process to close the IPC channel as well.</p>
<h3 id="child-kill-signal-">child.kill([signal])</h3>
<ul>
<li><code>signal</code> {String}</li>
</ul>
<p>The <code>child.kill()</code> methods sends a signal to the child process. If no argument
is given, the process will be sent the <code>&#39;SIGTERM&#39;</code> signal. See <code>signal(7)</code> for
a list of available signals.</p>
<pre><code class="lang-js">const spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
const grep = spawn(<span class="hljs-string">'grep'</span>, [<span class="hljs-string">'ssh'</span>]);

grep.<span class="hljs-literal">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-params">(code, signal)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(
    `<span class="javascript">child process terminated due to receipt <span class="hljs-keyword">of</span> signal ${signal}</span>`);
});

<span class="hljs-regexp">//</span> Send SIGHUP to process
grep.kill(<span class="hljs-string">'SIGHUP'</span>);
</code></pre>
<p>The <code>ChildProcess</code> object may emit an <code>&#39;error&#39;</code> event if the signal cannot be
delivered. Sending a signal to a child process that has already exited is not
an error but may have unforeseen consequences. Specifically, if the process
identifier (PID) has been reassigned to another process, the signal will be
delivered to that process instead which can have unexpected results.</p>
<p>Note that while the function is called <code>kill</code>, the signal delivered to the
child process may not actually terminate the process.</p>
<p>See <code>kill(2)</code></p>
<h3 id="child-pid">child.pid</h3>
<ul>
<li>{Number} Integer</li>
</ul>
<p>Returns the process identifier (PID) of the child process.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).spawn;
<span class="hljs-keyword">const</span> grep = spawn(<span class="hljs-string">'grep'</span>, [<span class="hljs-string">'ssh'</span>]);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Spawned child pid: <span class="hljs-subst">${grep.pid}</span>`</span>);
grep.stdin.end();
</code></pre>
<h3 id="child-send-message-sendhandle-options-callback-">child.send(message[, sendHandle[, options]][, callback])</h3>
<ul>
<li><code>message</code> {Object}</li>
<li><code>sendHandle</code> {Handle}</li>
<li><code>options</code> {Object}</li>
<li><code>callback</code> {Function}</li>
<li>Return: {Boolean}</li>
</ul>
<p>When an IPC channel has been established between the parent and child (
i.e. when using <a href="#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>), the <code>child.send()</code> method can be
used to send messages to the child process. When the child process is a Node.js
instance, these messages can be received via the <code>process.on(&#39;message&#39;)</code> event.</p>
<p>For example, in the parent script:</p>
<pre><code class="lang-js">const cp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>);
const n = cp.fork(`<span class="javascript">${__dirname}/sub.js</span>`);

n.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(m)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'PARENT got message:'</span>, m);
});

n.send({ <span class="hljs-attribute">hello</span>: <span class="hljs-string">'world'</span> });
</code></pre>
<p>And then the child script, <code>&#39;sub.js&#39;</code> might look like this:</p>
<pre><code class="lang-js">process.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(m)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'CHILD got message:'</span>, m);
});

process.send({ <span class="hljs-attribute">foo</span>: <span class="hljs-string">'bar'</span> });
</code></pre>
<p>Child Node.js processes will have a <code>process.send()</code> method of their own that
allows the child to send messages back to the parent.</p>
<p>There is a special case when sending a <code>{cmd: &#39;NODE_foo&#39;}</code> message. All messages
containing a <code>NODE_</code> prefix in its <code>cmd</code> property are considered to be reserved
for use within Node.js core and will not be emitted in the child&#39;s
<code>process.on(&#39;message&#39;)</code> event. Rather, such messages are emitted using the
<code>process.on(&#39;internalMessage&#39;)</code> event and are consumed internally by Node.js.
Applications should avoid using such messages or listening for
<code>&#39;internalMessage&#39;</code> events as it is subject to change without notice.</p>
<p>The optional <code>sendHandle</code> argument that may be passed to <code>child.send()</code> is for
passing a TCP server or socket object to the child process. The child will
receive the object as the second argument passed to the callback function
registered on the <code>process.on(&#39;message&#39;)</code> event.</p>
<p>The <code>options</code> argument, if present, is an object used to parameterize the
sending of certain types of handles. <code>options</code> supports the following
properties:</p>
<ul>
<li><code>keepOpen</code> - A Boolean value that can be used when passing instances of
<code>net.Socket</code>. When <code>true</code>, the socket is kept open in the sending process.
Defaults to <code>false</code>.</li>
</ul>
<p>The optional <code>callback</code> is a function that is invoked after the message is
sent but before the child may have received it.  The function is called with a
single argument: <code>null</code> on success, or an <a href="errors.html#errors_class_error"><code>Error</code></a> object on failure.</p>
<p>If no <code>callback</code> function is provided and the message cannot be sent, an
<code>&#39;error&#39;</code> event will be emitted by the <code>ChildProcess</code> object. This can happen,
for instance, when the child process has already exited.</p>
<p><code>child.send()</code> will return <code>false</code> if the channel has closed or when the
backlog of unsent messages exceeds a threshold that makes it unwise to send
more. Otherwise, the method returns <code>true</code>. The <code>callback</code> function can be
used to implement flow control.</p>
<h4 id="example-sending-a-server-object">Example: sending a server object</h4>
<p>The <code>sendHandle</code> argument can be used, for instance, to pass the handle of
a TCP server object to the child process as illustrated in the example below:</p>
<pre><code class="lang-js">const child = <span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).fork(<span class="hljs-string">'child.js'</span>);

<span class="hljs-regexp">//</span> Open up the server object <span class="hljs-keyword">and</span> send the handle.
const server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>).createServer();
server.<span class="hljs-literal">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> {
  socket.end(<span class="hljs-string">'handled by parent'</span>);
});
server.listen(<span class="hljs-number">1337</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  child.send(<span class="hljs-string">'server'</span>, server);
});
</code></pre>
<p>The child would then receive the server object as:</p>
<pre><code class="lang-js">process.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(m, server)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (m === <span class="hljs-string">'server'</span>) {
    server.<span class="hljs-literal">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> {
      socket.end(<span class="hljs-string">'handled by child'</span>);
    });
  }
});
</code></pre>
<p>Once the server is now shared between the parent and child, some connections
can be handled by the parent and some by the child.</p>
<p>While the example above uses a server created using the <code>net</code> module, <code>dgram</code>
module servers use exactly the same workflow with the exceptions of listening on
a <code>&#39;message&#39;</code> event instead of <code>&#39;connection&#39;</code> and using <code>server.bind</code> instead of
<code>server.listen</code>. This is, however, currently only supported on UNIX platforms.</p>
<h4 id="example-sending-a-socket-object">Example: sending a socket object</h4>
<p>Similarly, the <code>sendHandler</code> argument can be used to pass the handle of a
socket to the child process. The example below spawns two children that each
handle connections with &quot;normal&quot; or &quot;special&quot; priority:</p>
<pre><code class="lang-js">const normal = <span class="hljs-keyword">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-keyword">fork</span>(<span class="hljs-string">'child.js'</span>, [<span class="hljs-string">'normal'</span>]);
const special = <span class="hljs-keyword">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-keyword">fork</span>(<span class="hljs-string">'child.js'</span>, [<span class="hljs-string">'special'</span>]);

<span class="hljs-regexp">//</span> Open up the server <span class="hljs-keyword">and</span> <span class="hljs-keyword">send</span> sockets to child
const server = <span class="hljs-keyword">require</span>(<span class="hljs-string">'net'</span>).createServer();
server.on(<span class="hljs-string">'connection'</span>, (<span class="hljs-keyword">socket</span>) =&gt; {

  <span class="hljs-regexp">//</span> If this is special priority
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">socket</span>.remoteAddress === <span class="hljs-string">'74.125.127.100'</span>) {
    special.<span class="hljs-keyword">send</span>(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">socket</span>);
    <span class="hljs-keyword">return</span>;
  }
  // This is normal priority
  normal.<span class="hljs-keyword">send</span>(<span class="hljs-string">'socket'</span>, <span class="hljs-keyword">socket</span>);
});
server.<span class="hljs-keyword">listen</span>(<span class="hljs-number">1337</span>);
</code></pre>
<p>The <code>child.js</code> would receive the socket handle as the second argument passed
to the event callback function:</p>
<pre><code class="lang-js">process.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(m, socket)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (m === <span class="hljs-string">'socket'</span>) {
    socket.end(`<span class="javascript">Request handled <span class="hljs-keyword">with</span> ${process.argv[<span class="hljs-number">2</span>]} priority</span>`);
  }
});
</code></pre>
<p>Once a socket has been passed to a child, the parent is no longer capable of
tracking when the socket is destroyed. To indicate this, the <code>.connections</code>
property becomes <code>null</code>. It is recommended not to use <code>.maxConnections</code> when
this occurs.</p>
<p><em>Note: this function uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="nofollow"><code>JSON.stringify()</code></a> internally to serialize the <code>message</code>.</em></p>
<h3 id="child-stderr">child.stderr</h3>
<ul>
<li>{Stream}</li>
</ul>
<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stderr</code>.</p>
<p>If the child was spawned with <code>stdio[2]</code> set to anything other than <code>&#39;pipe&#39;</code>,
then this will be <code>undefined</code>.</p>
<p><code>child.stderr</code> is an alias for <code>child.stdio[2]</code>. Both properties will refer to
the same value.</p>
<h3 id="child-stdin">child.stdin</h3>
<ul>
<li>{Stream}</li>
</ul>
<p>A <code>Writable Stream</code> that represents the child process&#39;s <code>stdin</code>.</p>
<p><em>Note that if a child process waits to read all of its input, the child will not
continue until this stream has been closed via <code>end()</code>.</em></p>
<p>If the child was spawned with <code>stdio[0]</code> set to anything other than <code>&#39;pipe&#39;</code>,
then this will be <code>undefined</code>.</p>
<p><code>child.stdin</code> is an alias for <code>child.stdio[0]</code>. Both properties will refer to
the same value.</p>
<h3 id="child-stdio">child.stdio</h3>
<ul>
<li>{Array}</li>
</ul>
<p>A sparse array of pipes to the child process, corresponding with positions in
the <a href="#child_process_options_stdio"><code>stdio</code></a> option passed to <a href="#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a> that have been set
to the value <code>&#39;pipe&#39;</code>. Note that <code>child.stdio[0]</code>, <code>child.stdio[1]</code>, and
<code>child.stdio[2]</code> are also available as <code>child.stdin</code>, <code>child.stdout</code>, and
<code>child.stderr</code>, respectively.</p>
<p>In the following example, only the child&#39;s fd <code>1</code> (stdout) is configured as a
pipe, so only the parent&#39;s <code>child.stdio[1]</code> is a stream, all other values in
the array are <code>null</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> <span class="hljs-keyword">assert</span> = require(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">const</span> fs = require(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> child_process = require(<span class="hljs-string">'child_process'</span>);

<span class="hljs-keyword">const</span> child = child_process.spawn(<span class="hljs-string">'ls'</span>, {
    stdio: [
      <span class="hljs-number">0</span>, <span class="hljs-comment">// Use parents stdin for child</span>
      <span class="hljs-string">'pipe'</span>, <span class="hljs-comment">// Pipe child's stdout to parent</span>
      fs.openSync(<span class="hljs-string">'err.out'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-comment">// Direct child's stderr to a file</span>
    ]
});

<span class="hljs-keyword">assert</span>.equal(child.stdio[<span class="hljs-number">0</span>], <span class="hljs-keyword">null</span>);
<span class="hljs-keyword">assert</span>.equal(child.stdio[<span class="hljs-number">0</span>], child.stdin);

<span class="hljs-keyword">assert</span>(child.stdout);
<span class="hljs-keyword">assert</span>.equal(child.stdio[<span class="hljs-number">1</span>], child.stdout);

<span class="hljs-keyword">assert</span>.equal(child.stdio[<span class="hljs-number">2</span>], <span class="hljs-keyword">null</span>);
<span class="hljs-keyword">assert</span>.equal(child.stdio[<span class="hljs-number">2</span>], child.stderr);
</code></pre>
<h3 id="child-stdout">child.stdout</h3>
<ul>
<li>{Stream}</li>
</ul>
<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stdout</code>.</p>
<p>If the child was spawned with <code>stdio[1]</code> set to anything other than <code>&#39;pipe&#39;</code>,
then this will be <code>undefined</code>.</p>
<p><code>child.stdout</code> is an alias for <code>child.stdio[1]</code>. Both properties will refer
to the same value.</p>


          </section>
        </div>
      </div>
    </div>
    <script src="../assets/js/vendor/jquery.js"></script>
    <script src="../assets/js/vendor/fastclick.js"></script>
    <script src="../assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
  </html>