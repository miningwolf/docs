<!DOCTYPE html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>WolfScript API dgram</title>

  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="../assets/css/docs.css" rel="stylesheet" />
  <link href="../assets/css/github.css" rel="stylesheet" />
  <link href="../assets/fonts/foundation-icons.css" rel="stylesheet" />
   <script src="../assets/js/vendor/modernizr.js"></script>
</head>
<body>
  <body class="antialiased hide-extras">
    <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/web/index.html"><i class="fi-paw"></i> WolfScript.io</a></h1>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
      <li class="divider"></li>
         <li class='divider'></li>
<li><a href='../index.html' class=''>Docs</a></li>
<li class='divider'></li>
<li><a href='../wolfbuk/io/wolfscript/0.html' class=''>WolfBuk API</a></li>
<li class='divider'></li>
<li><a href='../wolfcanary/io/wolfscript/0.html' class=''>WolfCanary API</a></li>
<li class='divider'></li>
<li><a href='../wolfnode/globals.html' class=''>WolfNode</a></li>

       <li class="divider"></li>
       <li><a href='http://github.com/miningwolf/wolfscript ' class=''> <i class="fi-social-github"></i> Github</a></li>
       <li class="divider"></li>
       <li class="has-form">
       <a href="../GettingStarted.html " class="small button">Getting Started</a>
       </li>
    </ul>
  </section>
</nav>
<ul class="breadcrumbs">
<li><a href='../index.html'>Docs </a></li>
 <li><a href='../wolfnode/globals.html'>wolfnode</a></li>
<li class='current'><a href='#'>dgram</a></li>

</ul>

      <div class="row">
        <div class="large-3 medium-4 columns">
          <div class="hide-for-small">
            <div class="sidebar">
              <nav>
                <ul class="side-nav accordion" data-accordion>
                  <li class='heading'><a href='../wolfnode/globals.html' class=''>WolfNode</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/buffer.html' class=''>Core</a></li> 
<li><a href='../wolfnode/buffer.html'>buffer</a></li>
<li><a href='../wolfnode/console.html'>console</a></li>
<li><a href='../wolfnode/crypto.html'>crypto</a></li>
<li class='active'><a href='../wolfnode/dgram.html'>dgram</a></li>
<li><a href='../wolfnode/dns.html'>dns</a></li>
<li><a href='../wolfnode/events.html'>events</a></li>
<li><a href='../wolfnode/fs.html'>fs</a></li>
<li><a href='../wolfnode/http.html'>http</a></li>
<li><a href='../wolfnode/https.html'>https</a></li>
<li><a href='../wolfnode/net.html'>net</a></li>
<li><a href='../wolfnode/path.html'>path</a></li>
<li><a href='../wolfnode/process.html'>process</a></li>
<li><a href='../wolfnode/querystring.html'>querystring</a></li>
<li><a href='../wolfnode/stream.html'>stream</a></li>
<li><a href='../wolfnode/timers.html'>timers</a></li>
<li><a href='../wolfnode/tls.html'>tls</a></li>
<li><a href='../wolfnode/url.html'>url</a></li>
<li><a href='../wolfnode/util.html'>util</a></li>
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/assert.html' class=''>Other</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/errors.html' class=''>Unknown</a></li> 
<li class='divider'></li>

                  </ul>
              </nav>
            </div>
          </div>
        </div>
        <div class="large-9 medium-8 columns">
          <section class="doc-content">
            <h1 id="udp-datagram-sockets">UDP / Datagram Sockets</h1>
<pre><code><span class="hljs-attribute">Stability</span>: <span class="hljs-string">2 - Stable</span>
</code></pre><!-- name=dgram -->
<p>The <code>dgram</code> module provides an implementation of UDP Datagram sockets.</p>
<pre><code class="lang-js">const dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
const server = dgram.createSocket(<span class="hljs-string">'udp4'</span>);

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server error:\n${err.stack}</span>`);
  server.close();
});

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(msg, rinfo)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server got: ${msg} from ${rinfo.address}:${rinfo.port}</span>`);
});

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'listening'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  var address = server.address();
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server listening ${address.address}:${address.port}</span>`);
});

server.bind(<span class="hljs-number">41234</span>);
<span class="hljs-regexp">//</span> server listening <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">41234</span>
</code></pre>
<h2 id="class-dgram-socket">Class: dgram.Socket</h2>
<p>The <code>dgram.Socket</code> object is an <a href="events.html"><code>EventEmitter</code></a> that encapsulates the
datagram functionality.</p>
<p>New instances of <code>dgram.Socket</code> are created using <a href="#dgram_dgram_createsocket_options_callback"><code>dgram.createSocket()</code></a>.
The <code>new</code> keyword is not to be used to create <code>dgram.Socket</code> instances.</p>
<h3 id="event-close-">Event: &#39;close&#39;</h3>
<p>The <code>&#39;close&#39;</code> event is emitted after a socket is closed with <a href="#dgram_socket_close_callback"><code>close()</code></a>.
Once triggered, no new <code>&#39;message&#39;</code> events will be emitted on this socket.</p>
<h3 id="event-error-">Event: &#39;error&#39;</h3>
<ul>
<li><code>exception</code> {Error}</li>
</ul>
<p>The <code>&#39;error&#39;</code> event is emitted whenever any error occurs. The event handler
function is passed a single Error object.</p>
<h3 id="event-listening-">Event: &#39;listening&#39;</h3>
<p>The <code>&#39;listening&#39;</code> event is emitted whenever a socket begins listening for
datagram messages. This occurs as soon as UDP sockets are created.</p>
<h3 id="event-message-">Event: &#39;message&#39;</h3>
<ul>
<li><code>msg</code> {Buffer} - The message</li>
<li><code>rinfo</code> {Object} - Remote address information</li>
</ul>
<p>The <code>&#39;message&#39;</code> event is emitted when a new datagram is available on a socket.
The event handler function is passed two arguments: <code>msg</code> and <code>rinfo</code>. The
<code>msg</code> argument is a <a href="buffer.html"><code>Buffer</code></a> and <code>rinfo</code> is an object with the sender&#39;s
address information provided by the <code>address</code>, <code>family</code> and <code>port</code> properties:</p>
<pre><code class="lang-js">socket.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(msg, rinfo)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Received %d bytes from %s:%d\n'</span>,
              msg.length, rinfo.address, rinfo.port);
});
</code></pre>
<h3 id="socket-addmembership-multicastaddress-multicastinterface-">socket.addMembership(multicastAddress[, multicastInterface])</h3>
<ul>
<li><code>multicastAddress</code> {String}</li>
<li><code>multicastInterface</code> {String}, Optional</li>
</ul>
<p>Tells the kernel to join a multicast group at the given <code>multicastAddress</code>
using the <code>IP_ADD_MEMBERSHIP</code> socket option. If the <code>multicastInterface</code>
argument is not specified, the operating system will try to add membership to
all valid networking interfaces.</p>
<h3 id="socket-address-">socket.address()</h3>
<p>Returns an object containing the address information for a socket.
For UDP sockets, this object will contain <code>address</code>, <code>family</code> and <code>port</code>
properties.</p>
<h3 id="socket-bind-port-address-callback-">socket.bind([port][, address][, callback])</h3>
<ul>
<li><code>port</code> {Number} - Integer, Optional</li>
<li><code>address</code> {String}, Optional</li>
<li><code>callback</code> {Function} with no parameters, Optional. Called when
binding is complete.</li>
</ul>
<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram messages on a
named <code>port</code> and optional <code>address</code>. If <code>port</code> is not specified, the operating
system will attempt to bind to a random port. If <code>address</code> is not specified,
the operating system will attempt to listen on all addresses.  Once binding is
complete, a <code>&#39;listening&#39;</code> event is emitted and the optional <code>callback</code> function
is called.</p>
<p>Note that specifying both a <code>&#39;listening&#39;</code> event listener and passing a
<code>callback</code> to the <code>socket.bind()</code> method is not harmful but not very
useful.</p>
<p>A bound datagram socket keeps the Node.js process running to receive
datagram messages.</p>
<p>If binding fails, an <code>&#39;error&#39;</code> event is generated. In rare case (e.g.
attempting to bind with a closed socket), an <a href="errors.html#errors_class_error"><code>Error</code></a> may be thrown.</p>
<p>Example of a UDP server listening on port 41234:</p>
<pre><code class="lang-js">const dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
const server = dgram.createSocket(<span class="hljs-string">'udp4'</span>);

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server error:\n${err.stack}</span>`);
  server.close();
});

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-params">(msg, rinfo)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server got: ${msg} from ${rinfo.address}:${rinfo.port}</span>`);
});

server.<span class="hljs-literal">on</span>(<span class="hljs-string">'listening'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  var address = server.address();
  <span class="hljs-built_in">console</span>.log(`<span class="javascript">server listening ${address.address}:${address.port}</span>`);
});

server.bind(<span class="hljs-number">41234</span>);
<span class="hljs-regexp">//</span> server listening <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">41234</span>
</code></pre>
<h3 id="socket-bind-options-callback-">socket.bind(options[, callback])</h3>
<ul>
<li><code>options</code> {Object} - Required. Supports the following properties:<ul>
<li><code>port</code> {Number} - Required.</li>
<li><code>address</code> {String} - Optional.</li>
<li><code>exclusive</code> {Boolean} - Optional.</li>
</ul>
</li>
<li><code>callback</code> {Function} - Optional.</li>
</ul>
<p>For UDP sockets, causes the <code>dgram.Socket</code> to listen for datagram messages on a
named <code>port</code> and optional <code>address</code> that are passed as properties of an
<code>options</code> object passed as the first argument. If <code>port</code> is not specified, the
operating system will attempt to bind to a random port. If <code>address</code> is not
specified, the operating system will attempt to listen on all addresses.  Once
binding is complete, a <code>&#39;listening&#39;</code> event is emitted and the optional
<code>callback</code> function is called.</p>
<p>The <code>options</code> object may contain an additional <code>exclusive</code> property that is
use when using <code>dgram.Socket</code> objects with the [<code>cluster</code>] module. When
<code>exclusive</code> is set to <code>false</code> (the default), cluster workers will use the same
underlying socket handle allowing connection handling duties to be shared.
When <code>exclusive</code> is <code>true</code>, however, the handle is not shared and attempted
port sharing results in an error.</p>
<p>An example socket listening on an exclusive port is shown below.</p>
<pre><code class="lang-js"><span class="hljs-tag">socket</span><span class="hljs-class">.bind</span>({
  <span class="hljs-attribute">address</span>: <span class="hljs-string">'localhost'</span>,
  <span class="hljs-attribute">port</span>: <span class="hljs-number">8000</span>,
  <span class="hljs-attribute">exclusive</span>: true
});
</code></pre>
<h3 id="socket-close-callback-">socket.close([callback])</h3>
<p>Close the underlying socket and stop listening for data on it. If a callback is
provided, it is added as a listener for the <a href="#dgram_event_close"><code>&#39;close&#39;</code></a> event.</p>
<h3 id="socket-dropmembership-multicastaddress-multicastinterface-">socket.dropMembership(multicastAddress[, multicastInterface])</h3>
<ul>
<li><code>multicastAddress</code> {String}</li>
<li><code>multicastInterface</code> {String}, Optional</li>
</ul>
<p>Instructs the kernel to leave a multicast group at <code>multicastAddress</code> using the
<code>IP_DROP_MEMBERSHIP</code> socket option. This method is automatically called by the
kernel when the socket is closed or the process terminates, so most apps will
never have reason to call this.</p>
<p>If <code>multicastInterface</code> is not specified, the operating system will attempt to
drop membership on all valid interfaces.</p>
<h3 id="socket-send-msg-offset-length-port-address-callback-">socket.send(msg, [offset, length,] port, address[, callback])</h3>
<ul>
<li><code>msg</code> {Buffer|String|Array} Message to be sent</li>
<li><code>offset</code> {Number} Integer. Optional. Offset in the buffer where the message starts.</li>
<li><code>length</code> {Number} Integer. Optional. Number of bytes in the message.</li>
<li><code>port</code> {Number} Integer. Destination port.</li>
<li><code>address</code> {String} Destination hostname or IP address.</li>
<li><code>callback</code> {Function} Called when the message has been sent. Optional.</li>
</ul>
<p>Broadcasts a datagram on the socket. The destination <code>port</code> and <code>address</code> must
be specified.</p>
<p>The <code>msg</code> argument contains the message to be sent.
Depending on its type, different behavior can apply. If <code>msg</code> is a <code>Buffer</code>,
the <code>offset</code> and <code>length</code> specify the offset within the <code>Buffer</code> where the
message begins and the number of bytes in the message, respectively.
If <code>msg</code> is a <code>String</code>, then it is automatically converted to a <code>Buffer</code>
with <code>&#39;utf8&#39;</code> encoding. With messages that
contain  multi-byte characters, <code>offset</code> and <code>length</code> will be calculated with
respect to <a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">byte length</a> and not the character position.
If <code>msg</code> is an array, <code>offset</code> and <code>length</code> must not be specified.</p>
<p>The <code>address</code> argument is a string. If the value of <code>address</code> is a host name,
DNS will be used to resolve the address of the host. If the <code>address</code> is not
specified or is an empty string, <code>&#39;127.0.0.1&#39;</code> or <code>&#39;::1&#39;</code> will be used instead.</p>
<p>If the socket has not been previously bound with a call to <code>bind</code>, the socket
is assigned a random port number and is bound to the &quot;all interfaces&quot; address
(<code>&#39;0.0.0.0&#39;</code> for <code>udp4</code> sockets, <code>&#39;::0&#39;</code> for <code>udp6</code> sockets.)</p>
<p>An optional <code>callback</code> function  may be specified to as a way of reporting
DNS errors or for determining when it is safe to reuse the <code>buf</code> object.
Note that DNS lookups delay the time to send for at least one tick of the
Node.js event loop.</p>
<p>The only way to know for sure that the datagram has been sent is by using a
<code>callback</code>. If an error occurs and a <code>callback</code> is given, the error will be
passed as the first argument to the <code>callback</code>. If a <code>callback</code> is not given,
the error is emitted as an <code>&#39;error&#39;</code> event on the <code>socket</code> object.</p>
<p>Offset and length are optional, but if you specify one you would need to
specify the other. Also, they are supported only when the first
argument is a <code>Buffer</code>.</p>
<p>Example of sending a UDP packet to a random port on <code>localhost</code>;</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-keyword">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> message = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'Some bytes'</span>);
<span class="hljs-keyword">const</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
client.send(message, <span class="hljs-number">41234</span>, <span class="hljs-string">'localhost'</span>, (err) =&gt; {
  client.close();
});
</code></pre>
<p>Example of sending a UDP packet composed of multiple buffers to a random port on <code>localhost</code>;</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-keyword">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'Some '</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'bytes'</span>);
<span class="hljs-keyword">const</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
client.send([buf1, buf2], <span class="hljs-number">41234</span>, <span class="hljs-string">'localhost'</span>, (err) =&gt; {
  client.close();
});
</code></pre>
<p>Sending multiple buffers might be faster or slower depending on your
application and operating system: benchmark it. Usually it is faster.</p>
<p><strong>A Note about UDP datagram size</strong></p>
<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code>
(<em>Maximum Transmission Unit</em>) and on the <code>Payload Length</code> field size.</p>
<ul>
<li><p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal
payload exceed 64K octets <em>including</em> the internet header and data
(65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);
this is generally true for loopback interfaces, but such long datagram
messages are impractical for most hosts and networks.</p>
</li>
<li><p>The <code>MTU</code> is the largest size a given link layer technology can support for
datagram messages. For any link, <code>IPv4</code> mandates a minimum <code>MTU</code> of <code>68</code>
octets, while the recommended <code>MTU</code> for IPv4 is <code>576</code> (typically recommended
as the <code>MTU</code> for dial-up type applications), whether they arrive whole or in
fragments.</p>
<p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets, however, the mandatory minimum
fragment reassembly buffer size is <code>1500</code> octets. The value of <code>68</code> octets is
very small, since most current link layer technologies, like Ethernet, have a
minimum <code>MTU</code> of <code>1500</code>.</p>
</li>
</ul>
<p>It is impossible to know in advance the MTU of each link through which
a packet might travel. Sending a datagram greater than the receiver <code>MTU</code> will
not work because the packet will get silently dropped without informing the
source that the data did not reach its intended recipient.</p>
<h3 id="socket-setbroadcast-flag-">socket.setBroadcast(flag)</h3>
<ul>
<li><code>flag</code> {Boolean}</li>
</ul>
<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When set to <code>true</code>, UDP
packets may be sent to a local interface&#39;s broadcast address.</p>
<h3 id="socket-setmulticastloopback-flag-">socket.setMulticastLoopback(flag)</h3>
<ul>
<li><code>flag</code> {Boolean}</li>
</ul>
<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When set to <code>true</code>,
multicast packets will also be received on the local interface.</p>
<h3 id="socket-setmulticastttl-ttl-">socket.setMulticastTTL(ttl)</h3>
<ul>
<li><code>ttl</code> {Number} Integer</li>
</ul>
<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  While TTL generally stands for
&quot;Time to Live&quot;, in this context it specifies the number of IP hops that a
packet is allowed to travel through, specifically for multicast traffic.  Each
router or gateway that forwards a packet decrements the TTL. If the TTL is
decremented to 0 by a router, it will not be forwarded.</p>
<p>The argument passed to to <code>socket.setMulticastTTL()</code> is a number of hops
between 0 and 255. The default on most systems is <code>1</code> but can vary.</p>
<h3 id="socket-setttl-ttl-">socket.setTTL(ttl)</h3>
<ul>
<li><code>ttl</code> {Number} Integer</li>
</ul>
<p>Sets the <code>IP_TTL</code> socket option. While TTL generally stands for &quot;Time to Live&quot;,
in this context it specifies the number of IP hops that a packet is allowed to
travel through.  Each router or gateway that forwards a packet decrements the
TTL.  If the TTL is decremented to 0 by a router, it will not be forwarded.
Changing TTL values is typically done for network probes or when multicasting.</p>
<p>The argument to <code>socket.setTTL()</code> is a number of hops between 1 and 255.
The default on most systems is 64 but can vary.</p>
<h3 id="socket-ref-">socket.ref()</h3>
<p>By default, binding a socket will cause it to block the Node.js process from
exiting as long as the socket is open. The <code>socket.unref()</code> method can be used
to exclude the socket from the reference counting that keeps the Node.js
process active. The <code>socket.ref()</code> method adds the socket back to the reference
counting and restores the default behavior.</p>
<p>Calling <code>socket.ref()</code> multiples times will have no additional effect.</p>
<p>The <code>socket.ref()</code> method returns a reference to the socket so calls can be
chained.</p>
<h3 id="socket-unref-">socket.unref()</h3>
<p>By default, binding a socket will cause it to block the Node.js process from
exiting as long as the socket is open. The <code>socket.unref()</code> method can be used
to exclude the socket from the reference counting that keeps the Node.js
process active, allowing the process to exit even if the socket is still
listening.</p>
<p>Calling <code>socket.unref()</code> multiple times will have no addition effect.</p>
<p>The <code>socket.unref()</code> method returns a reference to the socket so calls can be
chained.</p>
<h3 id="change-to-asynchronous-socket-bind-behavior">Change to asynchronous <code>socket.bind()</code> behavior</h3>
<p>As of Node.js v0.10, <a href="#dgram_socket_bind_options_callback"><code>dgram.Socket#bind()</code></a> changed to an asynchronous
execution model. Legacy code that assumes synchronous behavior, as in the
following example:</p>
<pre><code class="lang-js">const s = dgram.createSocket('udp4')<span class="hljs-comment">;</span>
s.bind(1234)<span class="hljs-comment">;</span>
s.addMembership('<span class="hljs-number">224.0.0.114</span>')<span class="hljs-comment">;</span>
</code></pre>
<p>Must be changed to pass a callback function to the <a href="#dgram_socket_bind_options_callback"><code>dgram.Socket#bind()</code></a>
function:</p>
<pre><code class="lang-js">const s = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
s.bind(<span class="hljs-number">1234</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  s.addMembership(<span class="hljs-string">'224.0.0.114'</span>);
});
</code></pre>
<h2 id="-dgram-module-functions"><code>dgram</code> module functions</h2>
<h3 id="dgram-createsocket-options-callback-">dgram.createSocket(options[, callback])</h3>
<ul>
<li><code>options</code> {Object}</li>
<li><code>callback</code> {Function} Attached as a listener to <code>&#39;message&#39;</code> events.</li>
<li>Returns: {dgram.Socket}</li>
</ul>
<p>Creates a <code>dgram.Socket</code> object. The <code>options</code> argument is an object that
should contain a <code>type</code> field of either <code>udp4</code> or <code>udp6</code> and an optional
boolean <code>reuseAddr</code> field.</p>
<p>When <code>reuseAddr</code> is <code>true</code> <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will reuse the address, even if
another process has already bound a socket on it. <code>reuseAddr</code> defaults to
<code>false</code>. An optional <code>callback</code> function can be passed specified which is added
as a listener for <code>&#39;message&#39;</code> events.</p>
<p>Once the socket is created, calling <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will instruct the
socket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are
not passed to  <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> the method will bind the socket to the &quot;all
interfaces&quot; address on a random port (it does the right thing for both <code>udp4</code>
and <code>udp6</code> sockets). The bound address and port can be retrieved using
<a href="#dgram_socket_address"><code>socket.address().address</code></a> and <a href="#dgram_socket_address"><code>socket.address().port</code></a>.</p>
<h3 id="dgram-createsocket-type-callback-">dgram.createSocket(type[, callback])</h3>
<ul>
<li><code>type</code> {String} - Either &#39;udp4&#39; or &#39;udp6&#39;</li>
<li><code>callback</code> {Function} - Attached as a listener to <code>&#39;message&#39;</code> events.
Optional</li>
<li>Returns: {dgram.Socket}</li>
</ul>
<p>Creates a <code>dgram.Socket</code> object of the specified <code>type</code>. The <code>type</code> argument
can be either <code>udp4</code> or <code>udp6</code>. An optional <code>callback</code> function can be passed
which is added as a listener for <code>&#39;message&#39;</code> events.</p>
<p>Once the socket is created, calling <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> will instruct the
socket to begin listening for datagram messages. When <code>address</code> and <code>port</code> are
not passed to  <a href="#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> the method will bind the socket to the &quot;all
interfaces&quot; address on a random port (it does the right thing for both <code>udp4</code>
and <code>udp6</code> sockets). The bound address and port can be retrieved using
<a href="#dgram_socket_address"><code>socket.address().address</code></a> and <a href="#dgram_socket_address"><code>socket.address().port</code></a>.</p>


          </section>
        </div>
      </div>
    </div>
    <script src="../assets/js/vendor/jquery.js"></script>
    <script src="../assets/js/vendor/fastclick.js"></script>
    <script src="../assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
  </html>