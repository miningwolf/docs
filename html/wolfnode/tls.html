<!DOCTYPE html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>WolfScript API tls</title>

  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="../assets/css/docs.css" rel="stylesheet" />
  <link href="../assets/css/github.css" rel="stylesheet" />
  <link href="../assets/fonts/foundation-icons.css" rel="stylesheet" />
   <script src="../assets/js/vendor/modernizr.js"></script>
</head>
<body>
  <body class="antialiased hide-extras">
    <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/web/index.html"><i class="fi-paw"></i> WolfScript.io</a></h1>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
      <li class="divider"></li>
         <li class='divider'></li>
<li><a href='../index.html' class=''>Docs</a></li>
<li class='divider'></li>
<li><a href='../wolfbuk/io/wolfscript/0.html' class=''>WolfBuk API</a></li>
<li class='divider'></li>
<li><a href='../wolfcanary/io/wolfscript/0.html' class=''>WolfCanary API</a></li>
<li class='divider'></li>
<li><a href='../wolfnode/globals.html' class=''>WolfNode</a></li>

       <li class="divider"></li>
       <li><a href='http://github.com/miningwolf/wolfscript ' class=''> <i class="fi-social-github"></i> Github</a></li>
       <li class="divider"></li>
       <li class="has-form">
       <a href="../GettingStarted.html " class="small button">Getting Started</a>
       </li>
    </ul>
  </section>
</nav>
<ul class="breadcrumbs">
<li><a href='../index.html'>Docs </a></li>
 <li><a href='../wolfnode/globals.html'>wolfnode</a></li>
<li class='current'><a href='#'>tls</a></li>

</ul>

      <div class="row">
        <div class="large-3 medium-4 columns">
          <div class="hide-for-small">
            <div class="sidebar">
              <nav>
                <ul class="side-nav accordion" data-accordion>
                  <li class='heading'><a href='../wolfnode/globals.html' class=''>WolfNode</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/buffer.html' class=''>Core</a></li> 
<li><a href='../wolfnode/buffer.html'>buffer</a></li>
<li><a href='../wolfnode/console.html'>console</a></li>
<li><a href='../wolfnode/crypto.html'>crypto</a></li>
<li><a href='../wolfnode/dgram.html'>dgram</a></li>
<li><a href='../wolfnode/dns.html'>dns</a></li>
<li><a href='../wolfnode/events.html'>events</a></li>
<li><a href='../wolfnode/fs.html'>fs</a></li>
<li><a href='../wolfnode/http.html'>http</a></li>
<li><a href='../wolfnode/https.html'>https</a></li>
<li><a href='../wolfnode/net.html'>net</a></li>
<li><a href='../wolfnode/path.html'>path</a></li>
<li><a href='../wolfnode/process.html'>process</a></li>
<li><a href='../wolfnode/querystring.html'>querystring</a></li>
<li><a href='../wolfnode/stream.html'>stream</a></li>
<li><a href='../wolfnode/timers.html'>timers</a></li>
<li class='active'><a href='../wolfnode/tls.html'>tls</a></li>
<li><a href='../wolfnode/url.html'>url</a></li>
<li><a href='../wolfnode/util.html'>util</a></li>
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/assert.html' class=''>Other</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/errors.html' class=''>Unknown</a></li> 
<li class='divider'></li>

                  </ul>
              </nav>
            </div>
          </div>
        </div>
        <div class="large-9 medium-8 columns">
          <section class="doc-content">
            <h1 id="tls-ssl-">TLS (SSL)</h1>
<pre><code><span class="hljs-attribute">Stability</span>: <span class="hljs-string">2 - Stable</span>
</code></pre><p>Use <code>require(&#39;tls&#39;)</code> to access this module.</p>
<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.</p>
<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this:</p>
<pre><code>openssl genrsa -out ryans-key<span class="hljs-class">.pem</span> <span class="hljs-number">2048</span>
</code></pre><p>All servers and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)
file. This is done with:</p>
<pre><code>openssl req -<span class="hljs-keyword">new</span> -sha256 -<span class="hljs-variable">key</span> ryans-<span class="hljs-variable">key</span>.pem -out ryans-csr.pem
</code></pre><p>To create a self-signed certificate with the CSR, do this:</p>
<pre><code>openssl x509 -req -<span class="hljs-keyword">in</span> ryans-csr<span class="hljs-class">.pem</span> -signkey ryans-key<span class="hljs-class">.pem</span> -out ryans-cert.pem
</code></pre><p>Alternatively you can send the CSR to a Certificate Authority for signing.</p>
<p>For Perfect Forward Secrecy, it is required to generate Diffie-Hellman
parameters:</p>
<pre><code>openssl dhparam -outform PEM -out dhparam<span class="hljs-class">.pem</span> <span class="hljs-number">2048</span>
</code></pre><p>To create a .pfx or .p12, do this:</p>
<pre><code>openssl pkcs12 -export -<span class="hljs-keyword">in</span> agent5-cert<span class="hljs-class">.pem</span> -inkey agent5-key<span class="hljs-class">.pem</span> \
      -certfile ca-cert<span class="hljs-class">.pem</span> -out agent5.pfx
</code></pre><ul>
<li><code>in</code>:  certificate</li>
<li><code>inkey</code>: private key</li>
<li><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<h2 id="alpn-npn-and-sni">ALPN, NPN and SNI</h2>
<!-- type=misc -->
<p>ALPN (Application-Layer Protocol Negotiation Extension), NPN (Next
Protocol Negotiation) and, SNI (Server Name Indication) are TLS
handshake extensions:</p>
<ul>
<li>ALPN/NPN - Allows the use of one TLS server for multiple protocols (HTTP,
SPDY, HTTP/2)</li>
<li>SNI - Allows the use of one TLS server for multiple hostnames with different
SSL certificates.</li>
</ul>
<h2 id="client-initiated-renegotiation-attack-mitigation">Client-initiated renegotiation attack mitigation</h2>
<!-- type=misc -->
<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportionate amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.</p>
<p>To mitigate this, renegotiation is limited to three times every 10 minutes. An
error is emitted on the <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> instance when the threshold is
exceeded. These limits are configurable:</p>
<ul>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is
10 minutes.</p>
</li>
</ul>
<p>Do not change the defaults without a full understanding of the implications.</p>
<p>To test the server, connect to it with <code>openssl s_client -connect address:port</code>
and tap <code>R&lt;CR&gt;</code> (i.e., the letter <code>R</code> followed by a carriage return) a few
times.</p>
<h2 id="modifying-the-default-tls-cipher-suite">Modifying the Default TLS Cipher suite</h2>
<p>Node.js is built with a default suite of enabled and disabled TLS ciphers.
Currently, the default cipher suite is:</p>
<pre><code>ECDHE-RSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-ECDSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES256-GCM-<span class="hljs-string">SHA384:</span>
ECDHE-ECDSA-AES256-GCM-<span class="hljs-string">SHA384:</span>
DHE-RSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES128-<span class="hljs-string">SHA256:</span>
DHE-RSA-AES128-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES256-<span class="hljs-string">SHA384:</span>
DHE-RSA-AES256-<span class="hljs-string">SHA384:</span>
ECDHE-RSA-AES256-<span class="hljs-string">SHA256:</span>
DHE-RSA-AES256-<span class="hljs-string">SHA256:</span>
<span class="hljs-string">HIGH:</span>
!<span class="hljs-string">aNULL:</span>
!<span class="hljs-string">eNULL:</span>
!<span class="hljs-string">EXPORT:</span>
!<span class="hljs-string">DES:</span>
!<span class="hljs-string">RC4:</span>
!<span class="hljs-string">MD5:</span>
!<span class="hljs-string">PSK:</span>
!<span class="hljs-string">SRP:</span>
!CAMELLIA
</code></pre><p>This default can be overriden entirely using the <code>--tls-cipher-list</code> command
line switch. For instance, the following makes
<code>ECDHE-RSA-AES128-GCM-SHA256:!RC4</code> the default TLS cipher suite:</p>
<pre><code><span class="hljs-keyword">node</span><span class="hljs-identifier"> </span><span class="hljs-title">--tls-cipher-list</span>=<span class="hljs-string">"ECDHE-RSA-AES128-GCM-SHA256:!RC4"</span>
</code></pre><p>Note that the default cipher suite included within Node.js has been carefully
selected to reflect current security best practices and risk mitigation.
Changing the default cipher suite can have a significant impact on the security
of an application. The <code>--tls-cipher-list</code> switch should by used only if
absolutely necessary.</p>
<h2 id="perfect-forward-secrecy">Perfect Forward Secrecy</h2>
<!-- type=misc -->
<p>The term &quot;<a href="https://en.wikipedia.org/wiki/Perfect_forward_secrecy" target="_blank" rel="nofollow">Forward Secrecy</a>&quot; or &quot;Perfect Forward Secrecy&quot; describes a feature of
key-agreement (i.e., key-exchange) methods. Practically it means that even if
the private key of a server is compromised, communication can only be
decrypted by eavesdroppers if they manage to obtain the key-pair specifically
generated for each session.</p>
<p>This is achieved by randomly generating a key pair for key-agreement on every
handshake (in contrast to using the same key for all sessions). Methods
implementing this technique, thus offering Perfect Forward Secrecy, are
called &quot;ephemeral&quot;.</p>
<p>Currently two methods are commonly used to achieve Perfect Forward Secrecy (note
the character &quot;E&quot; appended to the traditional abbreviations):</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" target="_blank" rel="nofollow">DHE</a> - An ephemeral version of the Diffie Hellman key-agreement protocol.</li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman" target="_blank" rel="nofollow">ECDHE</a> - An ephemeral version of the Elliptic Curve Diffie Hellman
key-agreement protocol.</li>
</ul>
<p>Ephemeral methods may have some performance drawbacks, because key generation
is expensive.</p>
<h2 id="class-cryptostream">Class: CryptoStream</h2>
<pre><code>Stability: 0 - Deprecated: Use [<span class="hljs-link_label">`tls.TLSSocket`</span>][<span class="hljs-link_reference"></span>] instead.
</code></pre><p>This is an encrypted stream.</p>
<h3 id="cryptostream-byteswritten">cryptoStream.bytesWritten</h3>
<p>A proxy to the underlying socket&#39;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.</p>
<h2 id="class-securepair">Class: SecurePair</h2>
<p>Returned by tls.createSecurePair.</p>
<h3 id="event-secure-">Event: &#39;secure&#39;</h3>
<p>This event is emitted from the SecurePair once the pair has successfully
established a secure connection.</p>
<p>As with checking for the server <a href="#event-secureconnection"><code>secureConnection</code></a>
event, <code>pair.cleartext.authorized</code> should be inspected to confirm whether the
certificate used is properly authorized.</p>
<h2 id="class-tls-server">Class: tls.Server</h2>
<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting only raw TCP connections, this accepts encrypted
connections using TLS or SSL.</p>
<h3 id="event-tlsclienterror-">Event: &#39;tlsClientError&#39;</h3>
<p><code>function (exception, tlsSocket) { }</code></p>
<p>When a client connection emits an <code>&#39;error&#39;</code> event before a secure connection is
established it will be forwarded here.</p>
<p><code>tlsSocket</code> is the <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> that the error originated from.</p>
<h3 id="event-newsession-">Event: &#39;newSession&#39;</h3>
<p><code>function (sessionId, sessionData, callback) { }</code></p>
<p>Emitted on creation of a TLS session. May be used to store sessions in external
storage. <code>callback</code> must be invoked eventually, otherwise no data will be
sent or received from the secure connection.</p>
<p>NOTE: adding this event listener will only have an effect on connections
established after the addition of the event listener.</p>
<h3 id="event-ocsprequest-">Event: &#39;OCSPRequest&#39;</h3>
<p><code>function (certificate, issuer, callback) { }</code></p>
<p>Emitted when the client sends a certificate status request. The server&#39;s
current certificate can be parsed to obtain the OCSP URL and certificate ID;
after obtaining an OCSP response <code>callback(null, resp)</code> is then invoked, where
<code>resp</code> is a <code>Buffer</code> instance. Both <code>certificate</code> and <code>issuer</code> are <code>Buffer</code>
DER-representations of the primary and issuer&#39;s certificates. They can be used
to obtain the OCSP certificate ID and OCSP endpoint URL.</p>
<p>Alternatively, <code>callback(null, null)</code> may be called, meaning that there was no
OCSP response.</p>
<p>Calling <code>callback(err)</code> will result in a <code>socket.destroy(err)</code> call.</p>
<p>Typical flow:</p>
<ol>
<li>Client connects to the server and sends an <code>&#39;OCSPRequest&#39;</code> to it (via status
info extension in ClientHello).</li>
<li>Server receives the request and invokes the <code>&#39;OCSPRequest&#39;</code> event listener
if present.</li>
<li>Server extracts the OCSP URL from either the <code>certificate</code> or <code>issuer</code> and
performs an <a href="https://en.wikipedia.org/wiki/OCSP_stapling" target="_blank" rel="nofollow">OCSP request</a> to the CA.</li>
<li>Server receives <code>OCSPResponse</code> from the CA and sends it back to the client
via the <code>callback</code> argument</li>
<li>Client validates the response and either destroys the socket or performs a
handshake.</li>
</ol>
<p>NOTE: <code>issuer</code> could be <code>null</code> if the certificate is self-signed or if the
issuer is not in the root certificates list. (An issuer may be provided via the
<code>ca</code> option.)</p>
<p>NOTE: adding this event listener will only have an effect on connections
established after the addition of the event listener.</p>
<p>NOTE: An npm module like <a href="https://npmjs.org/package/asn1.js" target="_blank" rel="nofollow">asn1.js</a> may be used to parse the certificates.</p>
<h3 id="event-resumesession-">Event: &#39;resumeSession&#39;</h3>
<p><code>function (sessionId, callback) { }</code></p>
<p>Emitted when the client wants to resume the previous TLS session. The event
listener may perform a lookup in external storage using the given <code>sessionId</code>
and invoke <code>callback(null, sessionData)</code> once finished. If the session can&#39;t be
resumed (i.e., doesn&#39;t exist in storage) one may call <code>callback(null, null)</code>.
Calling <code>callback(err)</code> will terminate incoming connection and destroy the
socket.</p>
<p>NOTE: adding this event listener will only have an effect on connections
established after the addition of the event listener.</p>
<p>Here&#39;s an example for using TLS session resumption:</p>
<pre><code class="lang-js">var tlsSessionStore = {};
server.<span class="hljs-literal">on</span>(<span class="hljs-string">'newSession'</span>, <span class="hljs-function"><span class="hljs-params">(id, data, cb)</span> =&gt;</span> {
  tlsSessionStore[id.toString(<span class="hljs-string">'hex'</span>)] = data;
  cb();
});
server.<span class="hljs-literal">on</span>(<span class="hljs-string">'resumeSession'</span>, <span class="hljs-function"><span class="hljs-params">(id, cb)</span> =&gt;</span> {
  cb(<span class="hljs-literal">null</span>, tlsSessionStore[id.toString(<span class="hljs-string">'hex'</span>)] || <span class="hljs-literal">null</span>);
});
</code></pre>
<h3 id="event-secureconnection-">Event: &#39;secureConnection&#39;</h3>
<p><code>function (tlsSocket) {}</code></p>
<p>This event is emitted after the handshaking process for a new connection has
successfully completed. The argument is an instance of <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> and
has all the common stream methods and events.</p>
<p><code>socket.authorized</code> is a boolean value which indicates if the
client has been verified by one of the supplied certificate authorities for the
server. If <code>socket.authorized</code> is false, then <code>socket.authorizationError</code> is
set to describe how authorization failed. Implied but worth mentioning:
depending on the settings of the TLS server, unauthorized connections may
be accepted.</p>
<p><code>socket.npnProtocol</code> is a string containing the selected NPN protocol
and <code>socket.alpnProtocol</code> is a string containing the selected ALPN
protocol. When both NPN and ALPN extensions are received, ALPN takes
precedence over NPN and the next protocol is selected by ALPN. When
ALPN has no selected protocol, this returns false.</p>
<p><code>socket.servername</code> is a string containing the server name requested with
SNI.</p>
<h3 id="server-addcontext-hostname-context-">server.addContext(hostname, context)</h3>
<p>Add secure context that will be used if the client request&#39;s SNI hostname
matches the supplied <code>hostname</code> (wildcards can be used). <code>context</code> can contain
<code>key</code>, <code>cert</code>, <code>ca</code> or any other properties from
<a href="#tls_tls_createsecurecontext_details"><code>tls.createSecureContext()</code></a> <code>options</code> argument.</p>
<h3 id="server-address-">server.address()</h3>
<p>Returns the bound address, the address family name, and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address"><code>net.Server.address()</code></a> for
more information.</p>
<h3 id="server-close-callback-">server.close([callback])</h3>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&#39;close&#39;</code>
event.  Optionally, you can pass a callback to listen for the <code>&#39;close&#39;</code> event.</p>
<h3 id="server-connections">server.connections</h3>
<p>The number of concurrent connections on the server.</p>
<h3 id="server-getticketkeys-">server.getTicketKeys()</h3>
<p>Returns a <code>Buffer</code> instance holding the keys currently used for
encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt" target="_blank" rel="nofollow">TLS Session Tickets</a></p>
<h3 id="server-listen-port-hostname-callback-">server.listen(port[, hostname][, callback])</h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the
<code>hostname</code> is omitted, the server will accept connections on any IPv6 address
(<code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. A
port value of zero will assign a random port.</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.</p>
<p>See <code>net.Server</code> for more information.</p>
<h3 id="server-setticketkeys-keys-">server.setTicketKeys(keys)</h3>
<p>Updates the keys for encryption/decryption of the <a href="https://www.ietf.org/rfc/rfc5077.txt" target="_blank" rel="nofollow">TLS Session Tickets</a>.</p>
<p>NOTE: the buffer should be 48 bytes long. See <code>ticketKeys</code> option in
<a href="#tlscreateserveroptions-secureconnectionlistener">tls.createServer</a> for
more information on how it is used.</p>
<p>NOTE: the change is effective only for future server connections. Existing
or currently pending server connections will use the previous keys.</p>
<h3 id="server-maxconnections">server.maxConnections</h3>
<p>Set this property to reject connections when the server&#39;s connection count
exceeds the specified threshold.</p>
<h2 id="class-tls-tlssocket">Class: tls.TLSSocket</h2>
<p>This is a wrapped version of <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> that does transparent encryption
of written data and all required TLS negotiation.</p>
<p>This instance implements the duplex <a href="stream.html#stream_stream">Stream</a> interface. It has all the
common stream methods and events.</p>
<p>Methods that return TLS connection metadata (e.g.
<a href="#tls_tlssocket_getpeercertificate_detailed"><code>tls.TLSSocket.getPeerCertificate()</code></a> will only return data while the
connection is open.</p>
<h3 id="new-tls-tlssocket-socket-options-">new tls.TLSSocket(socket[, options])</h3>
<p>Construct a new TLSSocket object from an existing TCP socket.</p>
<p><code>socket</code> is an instance of <a href="net.html#net_class_net_socket"><code>net.Socket</code></a></p>
<p><code>options</code> is an optional object that might contain following properties:</p>
<ul>
<li><p><code>secureContext</code>: An optional TLS context object from
 <a href="#tls_tls_createsecurecontext_details"><code>tls.createSecureContext()</code></a></p>
</li>
<li><p><code>isServer</code>: If <code>true</code> the TLS socket will be instantiated in server-mode.
Default: <code>false</code></p>
</li>
<li><p><code>server</code>: An optional <a href="net.html#net_class_net_server"><code>net.Server</code></a> instance</p>
</li>
<li><p><code>requestCert</code>: Optional, see <a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"><code>tls.createSecurePair()</code></a></p>
</li>
<li><p><code>rejectUnauthorized</code>: Optional, see <a href="#tls_tls_createsecurepair_context_isserver_requestcert_rejectunauthorized_options"><code>tls.createSecurePair()</code></a></p>
</li>
<li><p><code>NPNProtocols</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a></p>
</li>
<li><p><code>ALPNProtocols</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a></p>
</li>
<li><p><code>SNICallback</code>: Optional, see <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a></p>
</li>
<li><p><code>session</code>: Optional, a <code>Buffer</code> instance, containing a TLS session</p>
</li>
<li><p><code>requestOCSP</code>: Optional, if <code>true</code> the OCSP status request extension will
be added to the client hello and an <code>&#39;OCSPResponse&#39;</code> event will be emitted
on the socket before establishing a secure communication</p>
</li>
</ul>
<h3 id="event-ocspresponse-">Event: &#39;OCSPResponse&#39;</h3>
<p><code>function (response) { }</code></p>
<p>This event will be emitted if the <code>requestOCSP</code> option was set. <code>response</code> is a
<code>Buffer</code> containing the server&#39;s OCSP response.</p>
<p>Traditionally, the <code>response</code> is a signed object from the server&#39;s CA that
contains information about server&#39;s certificate revocation status.</p>
<h3 id="event-secureconnect-">Event: &#39;secureConnect&#39;</h3>
<p>This event is emitted after the handshaking process for a new connection has
successfully completed. The listener will be called regardless of whether or not
the server&#39;s certificate has been authorized. It is the user&#39;s responsibility to
test <code>tlsSocket.authorized</code> to see if the server certificate was signed by one
of the specified CAs. If <code>tlsSocket.authorized === false</code> then the error can be
found in <code>tlsSocket.authorizationError</code>. Also, if either ALPN or NPN was used
<code>tlsSocket.alpnProtocol</code> or <code>tlsSocket.npnProtocol</code> can be checked for the
negotiated protocol.</p>
<h3 id="tlssocket-address-">tlsSocket.address()</h3>
<p>Returns the bound address, the address family name, and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.,
<code>{ port: 12346, family: &#39;IPv4&#39;, address: &#39;127.0.0.1&#39; }</code></p>
<h3 id="tlssocket-authorized">tlsSocket.authorized</h3>
<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code>.</p>
<h3 id="tlssocket-authorizationerror">tlsSocket.authorizationError</h3>
<p>The reason why the peer&#39;s certificate has not been verified. This property
becomes available only when <code>tlsSocket.authorized === false</code>.</p>
<h3 id="tlssocket-encrypted">tlsSocket.encrypted</h3>
<p>Static boolean value, always <code>true</code>. May be used to distinguish TLS sockets
from regular ones.</p>
<h3 id="tlssocket-getcipher-">tlsSocket.getCipher()</h3>
<p>Returns an object representing the cipher name and the SSL/TLS protocol version
that first defined the cipher.</p>
<p>Example:
<code>{ name: &#39;AES256-SHA&#39;, version: &#39;TLSv1/SSLv3&#39; }</code></p>
<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a href="https://www.openssl.org/docs/manmaster/ssl/SSL_CIPHER_get_name.html" target="_blank" rel="nofollow">https://www.openssl.org/docs/manmaster/ssl/SSL_CIPHER_get_name.html</a> for more
information.</p>
<h3 id="tlssocket-getephemeralkeyinfo-">tlsSocket.getEphemeralKeyInfo()</h3>
<p>Returns an object representing the type, name, and size of parameter of
an ephemeral key exchange in <a href="#tls_perfect_forward_secrecy">Perfect Forward Secrecy</a> on a client
connection. It returns an empty object when the key exchange is not
ephemeral. As this is only supported on a client socket, it returns <code>null</code>
if called on a server socket. The supported types are &#39;DH&#39; and &#39;ECDH&#39;. The
<code>name</code> property is only available in &#39;ECDH&#39;.</p>
<p>Example:</p>
<pre><code><span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">type</span>:<span class="hljs-value"> <span class="hljs-string">'ECDH'</span>, name: <span class="hljs-string">'prime256v1'</span>, size: <span class="hljs-number">256</span> </span></span></span>}
</code></pre><h3 id="tlssocket-getpeercertificate-detailed-">tlsSocket.getPeerCertificate([ detailed ])</h3>
<p>Returns an object representing the peer&#39;s certificate. The returned object has
some properties corresponding to the fields of the certificate. If the
<code>detailed</code> argument is <code>true</code> the full chain with the <code>issuer</code> property will be
returned, if <code>false</code> only the top certificate without the <code>issuer</code> property.</p>
<p>Example:</p>
<pre><code>{ subject:
   { C: <span class="hljs-string">'UK'</span>,
     ST: <span class="hljs-string">'Acknack Ltd'</span>,
     L: <span class="hljs-string">'Rhys Jones'</span>,
     O: <span class="hljs-string">'node.js'</span>,
     OU: <span class="hljs-string">'Test TLS Certificate'</span>,
     <span class="hljs-literal">CN</span>: <span class="hljs-string">'localhost'</span> },
  issuerInfo:
   { C: <span class="hljs-string">'UK'</span>,
     ST: <span class="hljs-string">'Acknack Ltd'</span>,
     L: <span class="hljs-string">'Rhys Jones'</span>,
     O: <span class="hljs-string">'node.js'</span>,
     OU: <span class="hljs-string">'Test TLS Certificate'</span>,
     <span class="hljs-literal">CN</span>: <span class="hljs-string">'localhost'</span> },
  issuer:
   { <span class="hljs-attribute">...</span> another certificate <span class="hljs-attribute">...</span> },
  raw: &lt; RAW DER buffer &gt;,
  valid_from: <span class="hljs-string">'Nov 11 09:52:22 2009 GMT'</span>,
  valid_to: <span class="hljs-string">'Nov  6 09:52:22 2029 GMT'</span>,
  fingerprint: <span class="hljs-string">'2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF'</span>,
  serialNumber: <span class="hljs-string">'B9B0D332A1AA5635'</span> }
</code></pre><p>If the peer does not provide a certificate, it returns <code>null</code> or an empty
object.</p>
<h3 id="tlssocket-getprotocol-">tlsSocket.getProtocol()</h3>
<p>Returns a string containing the negotiated SSL/TLS protocol version of the
current connection. <code>&#39;unknown&#39;</code> will be returned for connected sockets that have
not completed the handshaking process. <code>null</code> will be returned for server
sockets or disconnected client sockets.</p>
<p>Examples:</p>
<pre><code><span class="hljs-string">'SSLv3'</span>
<span class="hljs-string">'TLSv1'</span>
<span class="hljs-string">'TLSv1.1'</span>
<span class="hljs-string">'TLSv1.2'</span>
<span class="hljs-string">'unknown'</span>
</code></pre><p>See <a href="https://www.openssl.org/docs/manmaster/ssl/SSL_get_version.html" target="_blank" rel="nofollow">https://www.openssl.org/docs/manmaster/ssl/SSL_get_version.html</a> for more
information.</p>
<h3 id="tlssocket-getsession-">tlsSocket.getSession()</h3>
<p>Returns the ASN.1 encoded TLS session or <code>undefined</code> if none was negotiated.
Could be used to speed up handshake establishment when reconnecting to the
server.</p>
<h3 id="tlssocket-gettlsticket-">tlsSocket.getTLSTicket()</h3>
<p>NOTE: Works only with client TLS sockets. Useful only for debugging, for
session reuse provide <code>session</code> option to <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a>.</p>
<p>Returns the TLS session ticket or <code>undefined</code> if none was negotiated.</p>
<h3 id="tlssocket-localaddress">tlsSocket.localAddress</h3>
<p>The string representation of the local IP address.</p>
<h3 id="tlssocket-localport">tlsSocket.localPort</h3>
<p>The numeric representation of the local port.</p>
<h3 id="tlssocket-remoteaddress">tlsSocket.remoteAddress</h3>
<p>The string representation of the remote IP address. For example,
<code>&#39;74.125.127.100&#39;</code> or <code>&#39;2001:4860:a005::68&#39;</code>.</p>
<h3 id="tlssocket-remotefamily">tlsSocket.remoteFamily</h3>
<p>The string representation of the remote IP family. <code>&#39;IPv4&#39;</code> or <code>&#39;IPv6&#39;</code>.</p>
<h3 id="tlssocket-remoteport">tlsSocket.remotePort</h3>
<p>The numeric representation of the remote port. For example, <code>443</code>.</p>
<h3 id="tlssocket-renegotiate-options-callback-">tlsSocket.renegotiate(options, callback)</h3>
<p>Initiate TLS renegotiation process. The <code>options</code> object may contain the
following fields: <code>rejectUnauthorized</code>, <code>requestCert</code>. (See [<code>tls.createServer
()</code>][] for details.) <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,
once the renegotiation is successfully completed.</p>
<p>NOTE: Can be used to request peer&#39;s certificate after the secure connection
has been established.</p>
<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code>handshakeTimeout</code> timeout.</p>
<h3 id="tlssocket-setmaxsendfragment-size-">tlsSocket.setMaxSendFragment(size)</h3>
<p>Set maximum TLS fragment size (default and maximum value is: <code>16384</code>, minimum
is: <code>512</code>). Returns <code>true</code> on success, <code>false</code> otherwise.</p>
<p>Smaller fragment sizes decrease the buffering latency on the client: larger
fragments are buffered by the TLS layer until the entire fragment is received
and its integrity is verified; large fragments can span multiple roundtrips
and their processing can be delayed due to packet loss or reordering. However,
smaller fragments add extra TLS framing bytes and CPU overhead, which may
decrease overall server throughput.</p>
<h2 id="tls-connect-options-callback-">tls.connect(options[, callback])</h2>
<h2 id="tls-connect-port-host-options-callback-">tls.connect(port[, host][, options][, callback])</h2>
<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or
<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to
<code>localhost</code>.) <code>options</code> should be an object which specifies:</p>
<ul>
<li><p><code>host</code>: Host the client should connect to.</p>
</li>
<li><p><code>port</code>: Port the client should connect to.</p>
</li>
<li><p><code>socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code>host</code> and <code>port</code>
are ignored.</p>
</li>
<li><p><code>path</code>: Creates unix socket connection to path. If this option is
specified, <code>host</code> and <code>port</code> are ignored.</p>
</li>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate, and
CA certs of the client in PFX or PKCS12 format.</p>
</li>
<li><p><code>key</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s
containing the private key of the client in PEM format.</p>
</li>
<li><p><code>passphrase</code>: A string containing the passphrase for the private key or pfx.</p>
</li>
<li><p><code>cert</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s
containing the certificate key of the client in PEM format.</p>
</li>
<li><p><code>ca</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s of trusted
certificates in PEM format. If this is omitted several well known &quot;root&quot;
CAs (like VeriSign) will be used. These are used to authorize connections.</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by
<code>:</code>. Uses the same default cipher suite as <a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification
fails; <code>err.code</code> contains the OpenSSL error code. Default: <code>true</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array of strings or <code>Buffer</code>s containing supported NPN
protocols. <code>Buffer</code>s should have the following format:
<code>0x05hello0x05world</code>, where the first byte is the next protocol name&#39;s
length. (Passing an array is usually be much simpler: <code>[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>
</li>
<li><p><code>ALPNProtocols</code>: An array of strings or <code>Buffer</code>s containing the
supported ALPN protocols. <code>Buffer</code>s should have following format:
<code>0x05hello0x05world</code>, where the first byte is the next protocol
name&#39;s length. (Passing an array is usually be much simpler:
<code>[&#39;hello&#39;, &#39;world&#39;]</code>.)</p>
</li>
<li><p><code>servername</code>: Server name for the SNI (Server Name Indication) TLS
extension.</p>
</li>
<li><p><code>checkServerIdentity(servername, cert)</code>: Provide an override for checking
the server&#39;s hostname against the certificate. Should return an error if
verification fails. Returns <code>undefined</code> if passing.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g., <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on the version of OpenSSL
installed in the environment and are defined in the constant
<a href="https://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS" target="_blank" rel="nofollow">SSL_METHODS</a>.</p>
</li>
<li><p><code>secureContext</code>: An optional TLS context object from
<code>tls.createSecureContext( ... )</code>. It can be used for caching client
certificates, keys, and CA certificates.</p>
</li>
<li><p><code>session</code>: A <code>Buffer</code> instance, containing TLS session.</p>
</li>
<li><p><code>minDHSize</code>: Minimum size of the DH parameter in bits to accept a TLS
connection. When a server offers a DH parameter with a size less
than this, the TLS connection is destroyed and an error is thrown. Default:
1024.</p>
</li>
</ul>
<p>The <code>callback</code> parameter will be added as a listener for the
<a href="#tls_event_secureconnect"><code>&#39;secureConnect&#39;</code></a> event.</p>
<p><code>tls.connect()</code> returns a <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a> object.</p>
<p>Here is an example of a client of echo server as described previously:</p>
<pre><code class="lang-js">const tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

const options = {
  <span class="hljs-regexp">//</span> These are necessary only <span class="hljs-keyword">if</span> using the client certificate authentication
  <span class="hljs-attribute">key</span>: fs.readFileSync(<span class="hljs-string">'client-key.pem'</span>),
  <span class="hljs-attribute">cert</span>: fs.readFileSync(<span class="hljs-string">'client-cert.pem'</span>),

  <span class="hljs-regexp">//</span> This <span class="hljs-keyword">is</span> necessary only <span class="hljs-keyword">if</span> the server uses the self-signed certificate
  <span class="hljs-attribute">ca</span>: [ fs.readFileSync(<span class="hljs-string">'server-cert.pem'</span>) ]
};

var socket = tls.connect(<span class="hljs-number">8000</span>, options, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'client connected'</span>,
              socket.authorized ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(<span class="hljs-string">'utf8'</span>);
socket.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(data);
});
socket.<span class="hljs-literal">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  server.close();
});
</code></pre>
<p>Or</p>
<pre><code class="lang-js">const tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

const options = {
  <span class="hljs-attribute">pfx</span>: fs.readFileSync(<span class="hljs-string">'client.pfx'</span>)
};

var socket = tls.connect(<span class="hljs-number">8000</span>, options, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'client connected'</span>,
              socket.authorized ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(<span class="hljs-string">'utf8'</span>);
socket.<span class="hljs-literal">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-params">(data)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(data);
});
socket.<span class="hljs-literal">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  server.close();
});
</code></pre>
<h2 id="tls-createsecurecontext-options-">tls.createSecureContext(options)</h2>
<p>Creates a credentials object; the <code>options</code> object may contain the following
fields:</p>
<ul>
<li><code>pfx</code> : A string or <code>Buffer</code> holding the PFX or PKCS12 encoded private
key, certificate, and CA certificates.</li>
<li><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. To support multiple keys using different algorithms, an array
can be provided. It can either be a plain array of keys or an array of
objects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</li>
<li><code>passphrase</code> : A string containing the passphrase for the private key or pfx.</li>
<li><code>cert</code> : A string containing the PEM encoded certificate</li>
<li><code>ca</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s of trusted
certificates in PEM format. If this is omitted several well known &quot;root&quot;
CAs (like VeriSign) will be used. These are used to authorize connections.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List).</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT" target="_blank" rel="nofollow">https://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</li>
<li><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences. For further details see <code>tls</code> module
documentation.</li>
</ul>
<p>If no &#39;CA&#39; details are given, then Node.js will use the default
publicly trusted list of CAs as given in
<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt" target="_blank" rel="nofollow">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>
<h2 id="tls-createsecurepair-context-isserver-requestcert-rejectunauthorized-options-">tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])</h2>
<p>Creates a new secure pair object with two streams, one of which reads and writes
the encrypted data and the other of which reads and writes the cleartext data.
Generally, the encrypted stream is piped to/from an incoming encrypted data
stream and the cleartext one is used as a replacement for the initial encrypted
stream.</p>
<ul>
<li><p><code>credentials</code>: A secure context object from <code>tls.createSecureContext( ... )</code>.</p>
</li>
<li><p><code>isServer</code>: A boolean indicating whether this TLS connection should be
opened as a server or a client.</p>
</li>
<li><p><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</p>
</li>
<li><p><code>options</code>: An object with common SSL options. See <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a>.</p>
</li>
</ul>
<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and
<code>encrypted</code> stream properties.</p>
<p>NOTE: <code>cleartext</code> has the same API as <a href="#tls_class_tls_tlssocket"><code>tls.TLSSocket</code></a></p>
<h2 id="tls-createserver-options-secureconnectionlistener-">tls.createServer(options[, secureConnectionListener])</h2>
<p>Creates a new <a href="#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="#tls_event_secureconnection"><code>&#39;secureConnection&#39;</code></a> event.  The
<code>options</code> object may contain the following fields:</p>
<ul>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with
the <code>key</code>, <code>cert</code>, and <code>ca</code> options.)</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. To support multiple keys using different algorithms an array
can be provided. It can either be a plain array of keys or an array of
objects in the format <code>{pem: key, passphrase: passphrase}</code>. (Required)</p>
</li>
<li><p><code>passphrase</code>: A string containing the passphrase for the private key or pfx.</p>
</li>
<li><p><code>cert</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s
containing the certificate key of the server in PEM format. (Required)</p>
</li>
<li><p><code>ca</code>: A string, <code>Buffer</code>, array of strings, or array of <code>Buffer</code>s of trusted
certificates in PEM format. If this is omitted several well known &quot;root&quot;
CAs (like VeriSign) will be used. These are used to authorize connections.</p>
</li>
<li><p><code>crl</code> : Either a string or array of strings of PEM encoded CRLs (Certificate
Revocation List).</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude, separated by
<code>:</code>. The default cipher suite is:</p>
<pre><code class="lang-js">ECDHE-RSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-ECDSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES256-GCM-<span class="hljs-string">SHA384:</span>
ECDHE-ECDSA-AES256-GCM-<span class="hljs-string">SHA384:</span>
DHE-RSA-AES128-GCM-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES128-<span class="hljs-string">SHA256:</span>
DHE-RSA-AES128-<span class="hljs-string">SHA256:</span>
ECDHE-RSA-AES256-<span class="hljs-string">SHA384:</span>
DHE-RSA-AES256-<span class="hljs-string">SHA384:</span>
ECDHE-RSA-AES256-<span class="hljs-string">SHA256:</span>
DHE-RSA-AES256-<span class="hljs-string">SHA256:</span>
<span class="hljs-string">HIGH:</span>
!<span class="hljs-string">aNULL:</span>
!<span class="hljs-string">eNULL:</span>
!<span class="hljs-string">EXPORT:</span>
!<span class="hljs-string">DES:</span>
!<span class="hljs-string">RC4:</span>
!<span class="hljs-string">MD5:</span>
!<span class="hljs-string">PSK:</span>
!<span class="hljs-string">SRP:</span>
!CAMELLIA
</code></pre>
<p>The default cipher suite prefers GCM ciphers for <a href="https://www.chromium.org/Home/chromium-security/education/tls#TOC-Deprecation-of-TLS-Features-Algorithms-in-Chrome" target="_blank" rel="nofollow">Chrome&#39;s &#39;modern
cryptography&#39; setting</a> and also prefers ECDHE and DHE ciphers for Perfect
Forward Secrecy, while offering <em>some</em> backward compatibility.</p>
<p>128 bit AES is preferred over 192 and 256 bit AES in light of <a href="https://www.schneier.com/blog/archives/2009/07/another_new_aes.html" target="_blank" rel="nofollow">specific
attacks affecting larger AES key sizes</a>.</p>
<p>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers
(like Internet Explorer 6) cannot complete the handshaking process with
the default configuration. If these clients <em>must</em> be supported, the
<a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank" rel="nofollow">TLS recommendations</a> may offer a compatible cipher suite. For more details
on the format, see the <a href="https://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT" target="_blank" rel="nofollow">OpenSSL cipher list format documentation</a>.</p>
</li>
<li><p><code>ecdhCurve</code>: A string describing a named curve to use for ECDH key agreement
or false to disable ECDH.</p>
<p>Defaults to <code>prime256v1</code> (NIST P-256). Use <a href="crypto.html#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a> to
obtain a list of available curve names. On recent releases,
<code>openssl ecparam -list_curves</code> will also display the name and description of
each available elliptic curve.</p>
</li>
<li><p><code>dhparam</code>: A string or <code>Buffer</code> containing Diffie Hellman parameters,
required for Perfect Forward Secrecy. Use <code>openssl dhparam</code> to create it.
Its key length should be greater than or equal to 1024 bits, otherwise
it throws an error. It is strongly recommended to use 2048 bits or
larger for stronger security. If omitted or invalid, it is silently
discarded and DHE ciphers won&#39;t be available.</p>
</li>
<li><p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in the specified number of milliseconds. The default is 120 seconds.</p>
<p>A <code>&#39;clientError&#39;</code> is emitted on the <code>tls.Server</code> object whenever a handshake
times out.</p>
</li>
<li><p><code>honorCipherOrder</code> : When choosing a cipher, use the server&#39;s preferences
instead of the client preferences. Default: <code>true</code>.</p>
</li>
<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority.)</p>
</li>
<li><p><code>ALPNProtocols</code>: An array or <code>Buffer</code> of possible ALPN
protocols. (Protocols should be ordered by their priority.) When
the server receives both NPN and ALPN extensions from the client,
ALPN takes precedence over NPN and the server does not send an NPN
extension to the client.</p>
</li>
<li><p><code>SNICallback(servername, cb)</code>: A function that will be called if the client
supports SNI TLS extension. Two arguments will be passed to it:
<code>servername</code> and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where
<code>ctx</code> is a SecureContext instance. (<code>tls.createSecureContext(...)</code> can be
used to get a proper SecureContext.) If <code>SNICallback</code> wasn&#39;t provided the
default callback with high-level API will be used (see below).</p>
</li>
<li><p><code>sessionTimeout</code>: An integer specifying the number of seconds after which
the TLS session identifiers and TLS session tickets created by the server
will time out. See <a href="https://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html" target="_blank" rel="nofollow">SSL_CTX_set_timeout</a> for more details.</p>
</li>
<li><p><code>ticketKeys</code>: A 48-byte <code>Buffer</code> instance consisting of a 16-byte prefix,
a 16-byte HMAC key, and a 16-byte AES key. This can be used to accept TLS
session tickets on multiple instances of the TLS server.</p>
<p>NOTE: Automatically shared between <code>cluster</code> module workers.</p>
</li>
<li><p><code>sessionIdContext</code>: A string containing an opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is a 128 bit
truncated SHA1 hash value generated from the command-line. Otherwise, a
default is not provided.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g., <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on the version of OpenSSL
installed in the environment and are defined in the constant <a href="https://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS" target="_blank" rel="nofollow">SSL_METHODS</a>.</p>
</li>
</ul>
<p>Here is a simple example echo server:</p>
<pre><code class="lang-js">const tls = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tls'</span>);
const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

const options = {
  <span class="hljs-attribute">key</span>: fs.readFileSync(<span class="hljs-string">'server-key.pem'</span>),
  <span class="hljs-attribute">cert</span>: fs.readFileSync(<span class="hljs-string">'server-cert.pem'</span>),

  <span class="hljs-regexp">//</span> This <span class="hljs-keyword">is</span> necessary only <span class="hljs-keyword">if</span> using the client certificate authentication.
  <span class="hljs-attribute">requestCert</span>: <span class="hljs-literal">true</span>,

  <span class="hljs-regexp">//</span> This <span class="hljs-keyword">is</span> necessary only <span class="hljs-keyword">if</span> the client uses the self-signed certificate.
  <span class="hljs-attribute">ca</span>: [ fs.readFileSync(<span class="hljs-string">'client-cert.pem'</span>) ]
};

var server = tls.createServer(options, <span class="hljs-function"><span class="hljs-params">(socket)</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'server connected'</span>,
              socket.authorized ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  socket.write(<span class="hljs-string">'welcome!\n'</span>);
  socket.setEncoding(<span class="hljs-string">'utf8'</span>);
  socket.pipe(socket);
});
server.listen(<span class="hljs-number">8000</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'server bound'</span>);
});
</code></pre>
<p>Or</p>
<pre><code class="lang-js">const tls = <span class="hljs-keyword">require</span>(<span class="hljs-string">'tls'</span>);
const fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fs'</span>);

const options = {
  pfx: fs.readFileSync(<span class="hljs-string">'server.pfx'</span>),

  <span class="hljs-regexp">//</span> This is necessary only <span class="hljs-keyword">if</span> using the client certificate authentication.
  requestCert: true,

};

var server = tls.createServer(options, (<span class="hljs-keyword">socket</span>) =&gt; {
  console.<span class="hljs-keyword">log</span>(<span class="hljs-string">'server connected'</span>,
              <span class="hljs-keyword">socket</span>.authorized ? <span class="hljs-string">'authorized'</span> : <span class="hljs-string">'unauthorized'</span>);
  <span class="hljs-keyword">socket</span>.<span class="hljs-keyword">write</span>(<span class="hljs-string">'welcome!\n'</span>);
  <span class="hljs-keyword">socket</span>.setEncoding(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">socket</span>.<span class="hljs-keyword">pipe</span>(<span class="hljs-keyword">socket</span>);
});
server.<span class="hljs-keyword">listen</span>(<span class="hljs-number">8000</span>, () =&gt; {
  console.<span class="hljs-keyword">log</span>(<span class="hljs-string">'server bound'</span>);
});
</code></pre>
<p>You can test this server by connecting to it with <code>openssl s_client</code>:</p>
<pre><code>openssl s_client -connect <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8000</span>
</code></pre><h2 id="tls-getciphers-">tls.getCiphers()</h2>
<p>Returns an array with the names of the supported SSL ciphers.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> ciphers = tls.getCiphers();
console.log(ciphers); // [<span class="hljs-string">'AES128-SHA'</span>, <span class="hljs-string">'AES256-SHA'</span>, ...]
</code></pre>


          </section>
        </div>
      </div>
    </div>
    <script src="../assets/js/vendor/jquery.js"></script>
    <script src="../assets/js/vendor/fastclick.js"></script>
    <script src="../assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
  </html>