<!DOCTYPE html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>WolfScript API buffer</title>

  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="../assets/css/docs.css" rel="stylesheet" />
  <link href="../assets/css/github.css" rel="stylesheet" />
  <link href="../assets/fonts/foundation-icons.css" rel="stylesheet" />
   <script src="../assets/js/vendor/modernizr.js"></script>
</head>
<body>
  <body class="antialiased hide-extras">
    <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="/web/index.html"><i class="fi-paw"></i> WolfScript.io</a></h1>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
      <li class="divider"></li>
         <li class='divider'></li>
<li><a href='../index.html' class=''>Docs</a></li>
<li class='divider'></li>
<li><a href='../wolfbuk/io/wolfscript/0.html' class=''>WolfBuk API</a></li>
<li class='divider'></li>
<li><a href='../wolfcanary/io/wolfscript/0.html' class=''>WolfCanary API</a></li>
<li class='divider'></li>
<li><a href='../wolfnode/globals.html' class=''>WolfNode</a></li>

       <li class="divider"></li>
       <li><a href='http://github.com/miningwolf/wolfscript ' class=''> <i class="fi-social-github"></i> Github</a></li>
       <li class="divider"></li>
       <li class="has-form">
       <a href="../GettingStarted.html " class="small button">Getting Started</a>
       </li>
    </ul>
  </section>
</nav>
<ul class="breadcrumbs">
<li><a href='../index.html'>Docs </a></li>
 <li><a href='../wolfnode/globals.html'>wolfnode</a></li>
<li class='current'><a href='#'>buffer</a></li>

</ul>

      <div class="row">
        <div class="large-3 medium-4 columns">
          <div class="hide-for-small">
            <div class="sidebar">
              <nav>
                <ul class="side-nav accordion" data-accordion>
                  <li class='heading'><a href='../wolfnode/globals.html' class=''>WolfNode</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/buffer.html' class=''>Core</a></li> 
<li class='active'><a href='../wolfnode/buffer.html'>buffer</a></li>
<li><a href='../wolfnode/console.html'>console</a></li>
<li><a href='../wolfnode/crypto.html'>crypto</a></li>
<li><a href='../wolfnode/dgram.html'>dgram</a></li>
<li><a href='../wolfnode/dns.html'>dns</a></li>
<li><a href='../wolfnode/events.html'>events</a></li>
<li><a href='../wolfnode/fs.html'>fs</a></li>
<li><a href='../wolfnode/http.html'>http</a></li>
<li><a href='../wolfnode/https.html'>https</a></li>
<li><a href='../wolfnode/net.html'>net</a></li>
<li><a href='../wolfnode/path.html'>path</a></li>
<li><a href='../wolfnode/process.html'>process</a></li>
<li><a href='../wolfnode/querystring.html'>querystring</a></li>
<li><a href='../wolfnode/stream.html'>stream</a></li>
<li><a href='../wolfnode/timers.html'>timers</a></li>
<li><a href='../wolfnode/tls.html'>tls</a></li>
<li><a href='../wolfnode/url.html'>url</a></li>
<li><a href='../wolfnode/util.html'>util</a></li>
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/assert.html' class=''>Other</a></li> 
<li class='divider'></li>
<li class='heading'><a href='../wolfnode/errors.html' class=''>Unknown</a></li> 
<li class='divider'></li>

                  </ul>
              </nav>
            </div>
          </div>
        </div>
        <div class="large-9 medium-8 columns">
          <section class="doc-content">
            <h1 id="buffer">Buffer</h1>
<pre><code><span class="hljs-attribute">Stability</span>: <span class="hljs-string">2 - Stable</span>
</code></pre><p>Prior to the introduction of <code>TypedArray</code> in ECMAScript 2015 (ES6), the
JavaScript language had no mechanism for reading or manipulating streams
of binary data. The <code>Buffer</code> class was introduced as part of the Node.js
API to make it possible to interact with octet streams in the context of things
like TCP streams and file system operations.</p>
<p>Now that <code>TypedArray</code> has been added in ES6, the <code>Buffer</code> class implements the
<code>Uint8Array</code> API in a manner that is more optimized and suitable for Node.js&#39;
use cases.</p>
<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but
correspond to fixed-sized, raw memory allocations outside the V8 heap.
The size of the <code>Buffer</code> is established when it is created and cannot be
resized.</p>
<p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one
would need to ever use <code>require(&#39;buffer&#39;)</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.alloc(<span class="hljs-number">10</span>);
  <span class="hljs-comment">// Creates a zero-filled Buffer of length 10.</span>

<span class="hljs-keyword">const</span> buf2 = Buffer.alloc(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
  <span class="hljs-comment">// Creates a Buffer of length 10, filled with 0x01.</span>

<span class="hljs-keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="hljs-number">10</span>);
  <span class="hljs-comment">// Creates an uninitialized buffer of length 10.</span>
  <span class="hljs-comment">// This is faster than calling Buffer.alloc() but the returned</span>
  <span class="hljs-comment">// Buffer instance might contain old data that needs to be</span>
  <span class="hljs-comment">// overwritten using either fill() or write().</span>

<span class="hljs-keyword">const</span> buf4 = Buffer.<span class="hljs-keyword">from</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
  <span class="hljs-comment">// Creates a Buffer containing [01, 02, 03].</span>

<span class="hljs-keyword">const</span> buf5 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'test'</span>);
  <span class="hljs-comment">// Creates a Buffer containing ASCII bytes [74, 65, 73, 74].</span>

<span class="hljs-keyword">const</span> buf6 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'tést'</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-comment">// Creates a Buffer containing UTF8 bytes [74, c3, a9, 73, 74].</span>
</code></pre>
<h2 id="-buffer-from-buffer-alloc-and-buffer-allocunsafe-"><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></h2>
<p>In versions of Node.js prior to v6, <code>Buffer</code> instances were created using the
<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>
differently based on what arguments are provided:</p>
<ul>
<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),
allocates a new <code>Buffer</code> object of the specified size. The memory allocated
for such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive
data</em>. Such <code>Buffer</code> objects <em>must</em> be initialized <em>manually</em> by using either
<a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> or by writing to the <code>Buffer</code> completely. While this
behavior is <em>intentional</em> to improve performance, development experience has
demonstrated that a more explicit distinction is required between creating a
fast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li>
<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the
passed object&#39;s data into the <code>Buffer</code>.</li>
<li>Passing an <code>ArrayBuffer</code> returns a <code>Buffer</code> that shares allocated memory with
the given <code>ArrayBuffer</code>.</li>
</ul>
<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type
of value passed as the first argument, applications that do not properly
validate the input arguments passed to <code>new Buffer()</code>, or that fail to
appropriately initialize newly allocated <code>Buffer</code> content, can inadvertently
introduce security and reliability issues into their code.</p>
<p>To make the creation of <code>Buffer</code> objects more reliable and less error prone,
the various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>
and replaced by separate <code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and
<code>Buffer.allocUnsafe()</code> methods.</p>
<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors
to one of these new APIs.</em></p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing
a <em>copy</em> of the provided octets.</li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>
returns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given
<code>ArrayBuffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code>
containing a <em>copy</em> of the contents of the given <code>Buffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(str[, encoding])</code></a> returns a new <code>Buffer</code>
containing a <em>copy</em> of the provided string.</li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a &quot;filled&quot;
<code>Buffer</code> instance of the specified size. This method can be significantly
slower than <a href="#buffer_class_method_buffer_allocraw_size"><code>Buffer.allocUnsafe(size)</code></a> but ensures that
newly created <code>Buffer</code> instances never contain old and potentially sensitive
data.</li>
<li><a href="#buffer_class_method_buffer_allocraw_size"><code>Buffer.allocUnsafe(size)</code></a> returns a new <code>Buffer</code> of
the specified <code>size</code> whose content <em>must</em> be initialized using either
<a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> or written to completely.</li>
</ul>
<p><code>Buffer</code> instances returned by <code>Buffer.allocUnsafe(size)</code> <em>may</em> be allocated
off a shared internal memory pool if the <code>size</code> is less than or equal to half
<code>Buffer.poolSize</code>.</p>
<h3 id="the-zero-fill-buffers-command-line-option">The <code>--zero-fill-buffers</code> command line option</h3>
<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to
force all newly allocated <code>Buffer</code> and <code>SlowBuffer</code> instances created using
either <code>new Buffer(size)</code>, <code>Buffer.allocUnsafe(size)</code>, or
<code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of
this flag <em>changes the default behavior</em> of these methods and <em>can have a
significant impact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is
recommended only when absolutely necessary to enforce that newly allocated
<code>Buffer</code> instances cannot contain potentially sensitive data.</p>
<pre><code>$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(<span class="hljs-number">5</span>);
&lt;Buffer <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>&gt;
</code></pre><h3 id="what-makes-buffer-allocunsafe-size-unsafe-">What makes <code>Buffer.allocUnsafe(size)</code> &quot;unsafe&quot;?</h3>
<p>When calling <code>Buffer.allocUnsafe()</code>, the segment of allocated memory is
<em>uninitialized</em> (it is not zeroed-out). While this design makes the allocation
of memory quite fast, the allocated segment of memory might contain old data
that is potentially sensitive. Using a <code>Buffer</code> created by
<code>Buffer.allocUnsafe(size)</code> without <em>completely</em> overwriting the memory can
allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>
<p>While there are clear performance advantages to using <code>Buffer.allocUnsafe()</code>,
extra care <em>must</em> be taken in order to avoid introducing security
vulnerabilities into an application.</p>
<h2 id="buffers-and-character-encodings">Buffers and Character Encodings</h2>
<p>Buffers are commonly used to represent sequences of encoded characters
such as UTF8, UCS2, Base64 or even Hex-encoded data. It is possible to
convert back and forth between Buffers and ordinary JavaScript string objects
by using an explicit encoding method.</p>
<pre><code class="lang-js">const buf = Buffer.from(<span class="hljs-string">'hello world'</span>, <span class="hljs-string">'ascii'</span>);
console.<span class="hljs-built_in">log</span>(buf.toString(<span class="hljs-string">'hex'</span>));
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> <span class="hljs-number">68656</span>c6c6f20776f726c64
console.<span class="hljs-built_in">log</span>(buf.toString(<span class="hljs-string">'base64'</span>));
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> aGVsbG8gd29ybGQ=
</code></pre>
<p>The character encodings currently supported by Node.js include:</p>
<ul>
<li><p><code>&#39;ascii&#39;</code> - for 7-bit ASCII data only.  This encoding method is very fast and
will strip the high bit if set.</p>
</li>
<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>
</li>
<li><p><code>&#39;base64&#39;</code> - Base64 string encoding. When creating a buffer from a string,
this encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as
specified in <a href="https://tools.ietf.org/html/rfc4648#section-5" target="_blank" rel="nofollow">RFC 4648, Section 5</a>.</p>
</li>
<li><p><code>&#39;binary&#39;</code> - A way of encoding the buffer into a one-byte (<code>latin-1</code>)
encoded string. The string <code>&#39;latin-1&#39;</code> is not supported. Instead, pass
<code>&#39;binary&#39;</code> to use <code>&#39;latin-1&#39;</code> encoding.</p>
</li>
<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<h2 id="buffers-and-typedarray">Buffers and TypedArray</h2>
<p>Buffers are also <code>Uint8Array</code> TypedArray instances. However, there are subtle
incompatibilities with the TypedArray specification in ECMAScript 2015. For
instance, while <code>ArrayBuffer#slice()</code> creates a copy of the slice,
the implementation of <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the
existing Buffer without copying, making <code>Buffer#slice()</code> far more efficient.</p>
<p>It is also possible to create new TypedArray instances from a <code>Buffer</code> with the
following caveats:</p>
<ol>
<li><p>The <code>Buffer</code> object&#39;s memory is copied to the TypedArray, not shared.</p>
</li>
<li><p>The <code>Buffer</code> object&#39;s memory is interpreted as an array of distinct
elements, and not as a byte array of the target type. That is,
<code>new Uint32Array(Buffer.from([1,2,3,4]))</code> creates a 4-element <code>Uint32Array</code>
with elements <code>[1,2,3,4]</code>, not a <code>Uint32Array</code> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol>
<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as
a TypedArray instance by using the TypeArray object&#39;s <code>.buffer</code> property:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> Uint16Array(<span class="hljs-number">2</span>);
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-keyword">const</span> buf1 = Buffer.from(arr); <span class="hljs-comment">// copies the buffer</span>
<span class="hljs-keyword">const</span> buf2 = Buffer.from(arr.buffer); <span class="hljs-comment">// shares the memory with arr;</span>

console.<span class="hljs-built_in">log</span>(buf1);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 a0&gt;, copied buffer has only two elements</span>
console.<span class="hljs-built_in">log</span>(buf2);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>

arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;
console.<span class="hljs-built_in">log</span>(buf1);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 a0&gt;</span>
console.<span class="hljs-built_in">log</span>(buf2);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
</code></pre>
<p>Note that when creating a <code>Buffer</code> using the TypedArray&#39;s <code>.buffer</code>, it is
possible to use only a portion of the underlying <code>ArrayBuffer</code> by passing in
<code>byteOffset</code> and <code>length</code> parameters:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> Uint16Array(<span class="hljs-number">20</span>);
<span class="hljs-keyword">const</span> buf = Buffer.from(arr.buffer, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);
console.<span class="hljs-built_in">log</span>(buf.length);
  <span class="hljs-comment">// Prints: 16</span>
</code></pre>
<p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from" target="_blank" rel="nofollow"><code>TypedArray.from()</code></a> (e.g.<code>Uint8Array.from()</code>) have
different signatures and implementations. Specifically, the TypedArray variants
accept a second argument that is a mapping function that is invoked on every
element of the typed array:</p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping
function:</p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(str[, encoding])</code></a></li>
</ul>
<h2 id="buffers-and-es6-iteration">Buffers and ES6 iteration</h2>
<p>Buffers can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code> syntax:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-keyword">for</span> (var b of buf)
  console.<span class="hljs-built_in">log</span>(b)

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   1</span>
<span class="hljs-comment">//   2</span>
<span class="hljs-comment">//   3</span>
</code></pre>
<p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and
<a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p>
<h2 id="class-buffer">Class: Buffer</h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>
<h3 id="new-buffer-array-">new Buffer(array)</h3>
<pre><code>Stability: 0 - Deprecated: Use [<span class="hljs-link_label">`Buffer.from(array)`</span>][<span class="hljs-link_reference">buffer_from_array</span>]
instead.
</code></pre><ul>
<li><code>array</code> {Array}</li>
</ul>
<p>Allocates a new Buffer using an <code>array</code> of octets.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x62</span>,<span class="hljs-number">0x75</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x72</span>]);
  <span class="hljs-comment">// creates a new Buffer containing ASCII bytes</span>
  <span class="hljs-comment">// ['b','u','f','f','e','r']</span>
</code></pre>
<h3 id="new-buffer-buffer-">new Buffer(buffer)</h3>
<pre><code>Stability: 0 - Deprecated: Use [<span class="hljs-link_label">`Buffer.from(buffer)`</span>][<span class="hljs-link_reference">buffer_from_buffer</span>]
instead.
</code></pre><ul>
<li><code>buffer</code> {Buffer}</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'buffer'</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-keyword">new</span> Buffer(buf1);

buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x61</span>;
<span class="hljs-built_in">console</span>.log(buf1.toString());
  <span class="hljs-pi">// 'auffer'
console.log(buf2.toString());
  //</span> <span class="hljs-string">'buffer'</span> (copy <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> changed)
</code></pre>
<h3 id="new-buffer-arraybuffer-byteoffset-length-">new Buffer(arrayBuffer[, byteOffset [, length]])</h3>
<pre><code>Stability: 0 - Deprecated: Use
[<span class="hljs-link_label">`Buffer.from(arrayBuffer[, byteOffset [, length</span>]])`][buffer<span class="hljs-emphasis">_from_</span>arraybuf]
instead.
</code></pre><ul>
<li><code>arrayBuffer</code> {ArrayBuffer} The <code>.buffer</code> property of a <code>TypedArray</code> or a
<code>new ArrayBuffer()</code></li>
<li><code>byteOffset</code> {Number} Default: <code>0</code></li>
<li><code>length</code> {Number} Default: <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,
the newly created Buffer will share the same allocated memory as the
TypedArray.</p>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> Uint16Array(<span class="hljs-number">2</span>);
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(arr.buffer); <span class="hljs-comment">// shares the memory with arr;</span>

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>

<span class="hljs-comment">// changing the TypdArray changes the Buffer also</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
</code></pre>
<h3 id="new-buffer-size-">new Buffer(size)</h3>
<pre><code>Stability: 0 - Deprecated: Use
[<span class="hljs-link_label">`Buffer.alloc(size[, fill[, encoding</span>]])`][buffer_alloc] instead (also
see [<span class="hljs-link_label">`Buffer.allocUnsafe(size)`</span>][<span class="hljs-link_reference">buffer_allocunsafe</span>]).
</code></pre><ul>
<li><code>size</code> {Number}</li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than
or equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit
architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is
thrown. If a <code>size</code> less than 0 is specified, a zero-length Buffer will be
created.</p>
<p>Unlike <code>ArrayBuffers</code>, the underlying memory for <code>Buffer</code> instances created in
this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code> are
unknown and <em>could contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize
a <code>Buffer</code> to zeroes.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">5</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// &lt;Buffer 78 e0 82 02 01&gt;</span>
  <span class="hljs-comment">// (octets will be different, every time)</span>
buf.fill(<span class="hljs-number">0</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// &lt;Buffer 00 00 00 00 00&gt;</span>
</code></pre>
<h3 id="new-buffer-str-encoding-">new Buffer(str[, encoding])</h3>
<pre><code>Stability: 0 - Deprecated:
Use [<span class="hljs-link_label">`Buffer.from(str[, encoding</span>])`][buffer<span class="hljs-emphasis">_from_</span>string] instead.
</code></pre><ul>
<li><code>str</code> {String} string to encode.</li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
</ul>
<p>Creates a new Buffer containing the given JavaScript string <code>str</code>. If
provided, the <code>encoding</code> parameter identifies the strings character encoding.</p>
<pre><code class="lang-js">const buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'this is a tést'</span>);
console.<span class="hljs-built_in">log</span>(buf1.toString());
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">t</span>é<span class="hljs-keyword">st</span>
console.<span class="hljs-built_in">log</span>(buf1.toString(<span class="hljs-string">'ascii'</span>));
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> tC)<span class="hljs-keyword">st</span>

const buf2 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'7468697320697320612074c3a97374'</span>, <span class="hljs-string">'hex'</span>);
console.<span class="hljs-built_in">log</span>(buf2.toString());
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">t</span>é<span class="hljs-keyword">st</span>
</code></pre>
<h3 id="class-method-buffer-alloc-size-fill-encoding-">Class Method: Buffer.alloc(size[, fill[, encoding]])</h3>
<ul>
<li><code>size</code> {Number}</li>
<li><code>fill</code> {Value} Default: <code>undefined</code></li>
<li><code>encoding</code> {String} Default: <code>utf8</code></li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the
<code>Buffer</code> will be <em>zero-filled</em>.</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf </span>= <span class="hljs-keyword">Buffer.alloc(5);
</span><span class="hljs-label">console.log</span>(<span class="hljs-keyword">buf);
</span>  // &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>&gt;
</code></pre>
<p>The <code>size</code> must be less than or equal to the value of
<code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit architectures, <code>kMaxLength</code> is
<code>(2^31)-1</code>). Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. If a <code>size</code> less than 0
is specified, a zero-length <code>Buffer</code> will be created.</p>
<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling
<code>buf.fill(fill)</code>. See [<code>buf.fill()</code>][] for more information.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">5</span>, <span class="hljs-string">'a'</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// &lt;Buffer 61 61 61 61 61&gt;</span>
</code></pre>
<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be
initialized by calling <code>buf.fill(fill, encoding)</code>. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">11</span>, <span class="hljs-string">'aGVsbG8gd29ybGQ='</span>, <span class="hljs-string">'base64'</span>);
<span class="hljs-built_in">console</span>.log(buf);
  <span class="hljs-comment">// &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</span>
</code></pre>
<p>Calling <code>Buffer.alloc(size)</code> can be significantly slower than the alternative
<code>Buffer.allocUnsafe(size)</code> but ensures that the newly created <code>Buffer</code> instance
contents will <em>never contain sensitive data</em>.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3 id="class-method-buffer-allocunsafe-size-">Class Method: Buffer.allocUnsafe(size)</h3>
<ul>
<li><code>size</code> {Number}</li>
</ul>
<p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must
be less than or equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit
architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is
thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>Buffer</code> will be
created.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize such
<code>Buffer</code> instances to zeroes.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">5</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// &lt;Buffer 78 e0 82 02 01&gt;</span>
  <span class="hljs-comment">// (octets will be different, every time)</span>
buf.fill(<span class="hljs-number">0</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// &lt;Buffer 00 00 00 00 00&gt;</span>
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of
size <code>Buffer.poolSize</code> that is used as a pool for the fast allocation of new
<code>Buffer</code> instances created using <code>Buffer.allocUnsafe(size)</code> (and the deprecated
<code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to
<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <code>Buffer.poolSize</code> divided by two). The default
value of <code>Buffer.poolSize</code> is <code>8192</code> but can be modified.</p>
<p>Use of this pre-allocated internal memory pool is a key difference between
calling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.
Specifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal Buffer
pool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal
Buffer pool if <code>size</code> is less than or equal to half <code>Buffer.poolSize</code>. The
difference is subtle but can be important when an application requires the
additional performance that <code>Buffer.allocUnsafe(size)</code> provides.</p>
<h3 id="class-method-buffer-bytelength-string-encoding-">Class Method: Buffer.byteLength(string[, encoding])</h3>
<ul>
<li><code>string</code> {String}</li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li>Return: {Number}</li>
</ul>
<p>Returns the actual byte length of a string. This is not the same as
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length" target="_blank" rel="nofollow"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in
a string.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'\u00bd + \u00bc = \u00be'</span>;

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${str}</span>: <span class="hljs-subst">${str.length}</span> characters, `</span> +
            <span class="hljs-string">`<span class="hljs-subst">${Buffer.byteLength(str, 'utf8')}</span> bytes`</span>);

<span class="hljs-comment">// ½ + ¼ = ¾: 9 characters, 12 bytes</span>
</code></pre>
<h3 id="class-method-buffer-compare-buf1-buf2-">Class Method: Buffer.compare(buf1, buf2)</h3>
<ul>
<li><code>buf1</code> {Buffer}</li>
<li><code>buf2</code> {Buffer}</li>
<li>Return: {Number}</li>
</ul>
<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of
Buffers. This is equivalent is calling <a href="#buffer_buf_compare_otherbuffer"><code>buf1.compare(buf2)</code></a>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = [Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'1234'</span>), Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'0123'</span>)];
arr.sort(Buffer.compare);
</code></pre>
<h3 id="class-method-buffer-concat-list-totallength-">Class Method: Buffer.concat(list[, totalLength])</h3>
<ul>
<li><code>list</code> {Array} List of Buffer objects to concat</li>
<li><code>totalLength</code> {Number} Total length of the Buffers in the list
when concatenated</li>
<li>Return: {Buffer}</li>
</ul>
<p>Returns a new Buffer which is the result of concatenating all the Buffers in
the <code>list</code> together.</p>
<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length
Buffer is returned.</p>
<p>If <code>totalLength</code> is not provided, it is calculated from the Buffers in the
<code>list</code>. This, however, adds an additional loop to the function, so it is faster
to provide the length explicitly.</p>
<p>Example: build a single Buffer from a list of three Buffers:</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf1 </span>= <span class="hljs-keyword">Buffer.alloc(10);
</span><span class="hljs-label">const</span> <span class="hljs-keyword">buf2 </span>= <span class="hljs-keyword">Buffer.alloc(14);
</span><span class="hljs-label">const</span> <span class="hljs-keyword">buf3 </span>= <span class="hljs-keyword">Buffer.alloc(18);
</span><span class="hljs-label">const</span> totalLength = <span class="hljs-keyword">buf1.length </span>+ <span class="hljs-keyword">buf2.length </span>+ <span class="hljs-keyword">buf3.length;
</span>
<span class="hljs-label">console.log</span>(totalLength)<span class="hljs-comment">;</span>
<span class="hljs-label">const</span> <span class="hljs-keyword">bufA </span>= <span class="hljs-keyword">Buffer.concat([buf1, </span><span class="hljs-keyword">buf2, </span><span class="hljs-keyword">buf3], </span>totalLength)<span class="hljs-comment">;</span>
<span class="hljs-label">console.log</span>(<span class="hljs-keyword">bufA);
</span><span class="hljs-label">console.log</span>(<span class="hljs-keyword">bufA.length);
</span>
// <span class="hljs-number">42</span>
// &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> ...&gt;
// <span class="hljs-number">42</span>
</code></pre>
<h3 id="class-method-buffer-from-array-">Class Method: Buffer.from(array)</h3>
<ul>
<li><code>array</code> {Array}</li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x62</span>,<span class="hljs-number">0x75</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x72</span>]);
  <span class="hljs-comment">// creates a new Buffer containing ASCII bytes</span>
  <span class="hljs-comment">// ['b','u','f','f','e','r']</span>
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>
<h3 id="class-method-buffer-from-arraybuffer-byteoffset-length-">Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])</h3>
<ul>
<li><code>arrayBuffer</code> {ArrayBuffer} The <code>.buffer</code> property of a <code>TypedArray</code> or
a <code>new ArrayBuffer()</code></li>
<li><code>byteOffset</code> {Number} Default: <code>0</code></li>
<li><code>length</code> {Number} Default: <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <code>TypedArray</code> instance,
the newly created <code>Buffer</code> will share the same allocated memory as the
TypedArray.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> Uint16Array(<span class="hljs-number">2</span>);
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-keyword">const</span> buf = Buffer.from(arr.buffer); <span class="hljs-comment">// shares the memory with arr;</span>

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>

<span class="hljs-comment">// changing the TypedArray changes the Buffer also</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
</code></pre>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> ab = <span class="hljs-keyword">new</span> ArrayBuffer(<span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> buf = Buffer.from(ab, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
console.<span class="hljs-built_in">log</span>(buf.length);
  <span class="hljs-comment">// Prints: 2</span>
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <code>ArrayBuffer</code>.</p>
<h3 id="class-method-buffer-from-buffer-">Class Method: Buffer.from(buffer)</h3>
<ul>
<li><code>buffer</code> {Buffer}</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'buffer'</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.<span class="hljs-keyword">from</span>(buf1);

buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x61</span>;
<span class="hljs-built_in">console</span>.log(buf1.toString());
  <span class="hljs-pi">// 'auffer'
console.log(buf2.toString());
  //</span> <span class="hljs-string">'buffer'</span> (copy <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> changed)
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>
<h3 id="class-method-buffer-from-str-encoding-">Class Method: Buffer.from(str[, encoding])</h3>
<ul>
<li><code>str</code> {String} String to encode.</li>
<li><code>encoding</code> {String} Encoding to use, Default: <code>&#39;utf8&#39;</code></li>
</ul>
<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>str</code>. If
provided, the <code>encoding</code> parameter identifies the character encoding.
If not provided, <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.</p>
<pre><code class="lang-js">const buf1 = Buffer.from(<span class="hljs-string">'this is a tést'</span>);
console.<span class="hljs-built_in">log</span>(buf1.toString());
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">t</span>é<span class="hljs-keyword">st</span>
console.<span class="hljs-built_in">log</span>(buf1.toString(<span class="hljs-string">'ascii'</span>));
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> tC)<span class="hljs-keyword">st</span>

const buf2 = Buffer.from(<span class="hljs-string">'7468697320697320612074c3a97374'</span>, <span class="hljs-string">'hex'</span>);
console.<span class="hljs-built_in">log</span>(buf2.toString());
  // <span class="hljs-keyword">print</span><span class="hljs-variable">s:</span> this <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">t</span>é<span class="hljs-keyword">st</span>
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>
<h3 id="class-method-buffer-isbuffer-obj-">Class Method: Buffer.isBuffer(obj)</h3>
<ul>
<li><code>obj</code> {Object}</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns &#39;true&#39; if <code>obj</code> is a Buffer.</p>
<h3 id="class-method-buffer-isencoding-encoding-">Class Method: Buffer.isEncoding(encoding)</h3>
<ul>
<li><code>encoding</code> {String} The encoding string to test</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false
otherwise.</p>
<h3 id="buf-index-">buf[index]</h3>
<!--type=property-->
<!--name=[index]-->
<p>The index operator <code>[index]</code> can be used to get and set the octet at position
<code>index</code> in the Buffer. The values refer to individual bytes, so the legal value
range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>
<p>Example: copy an ASCII string into a Buffer, one byte at a time:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">"Node.js"</span>;
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-built_in">str</span>.length);

<span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.length ; i++) {
  buf[i] = <span class="hljs-built_in">str</span>.charCodeAt(i);
}

console.<span class="hljs-built_in">log</span>(buf.toString(<span class="hljs-string">'ascii'</span>));
  <span class="hljs-comment">// Prints: Node.js</span>
</code></pre>
<h3 id="buf-compare-otherbuffer-">buf.compare(otherBuffer)</h3>
<ul>
<li><code>otherBuffer</code> {Buffer}</li>
<li>Return: {Number}</li>
</ul>
<p>Compares two Buffer instances and returns a number indicating whether <code>buf</code>
comes before, after, or is the same as the <code>otherBuffer</code> in sort order.
Comparison is based on the actual sequence of bytes in each Buffer.</p>
<ul>
<li><code>0</code> is returned if <code>otherBuffer</code> is the same as <code>buf</code></li>
<li><code>1</code> is returned if <code>otherBuffer</code> should come <em>before</em> <code>buf</code> when sorted.</li>
<li><code>-1</code> is returned if <code>otherBuffer</code> should come <em>after</em> <code>buf</code> when sorted.</li>
</ul>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from('ABC');
<span class="hljs-keyword">const</span> buf2 = Buffer.from('BCD');
<span class="hljs-keyword">const</span> buf3 = Buffer.from('ABCD');

console.<span class="hljs-literal">log</span>(buf1.<span class="hljs-keyword">compare</span>(buf1));
  <span class="hljs-comment">// Prints: 0</span>
console.<span class="hljs-literal">log</span>(buf1.<span class="hljs-keyword">compare</span>(buf2));
  <span class="hljs-comment">// Prints: -1</span>
console.<span class="hljs-literal">log</span>(buf1.<span class="hljs-keyword">compare</span>(buf3));
  <span class="hljs-comment">// Prints: 1</span>
console.<span class="hljs-literal">log</span>(buf2.<span class="hljs-keyword">compare</span>(buf1));
  <span class="hljs-comment">// Prints: 1</span>
console.<span class="hljs-literal">log</span>(buf2.<span class="hljs-keyword">compare</span>(buf3));
  <span class="hljs-comment">// Prints: 1</span>

[buf1, buf2, buf3].<span class="hljs-keyword">sort</span>(Buffer.<span class="hljs-keyword">compare</span>);
  <span class="hljs-comment">// produces sort order [buf1, buf3, buf2]</span>
</code></pre>
<h3 id="buf-copy-targetbuffer-targetstart-sourcestart-sourceend-">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</h3>
<ul>
<li><code>targetBuffer</code> {Buffer} Buffer to copy into</li>
<li><code>targetStart</code> {Number} Default: 0</li>
<li><code>sourceStart</code> {Number} Default: 0</li>
<li><code>sourceEnd</code> {Number} Default: <code>buffer.length</code></li>
<li>Return: {Number} The number of bytes copied.</li>
</ul>
<p>Copies data from a region of this Buffer to a region in the target Buffer even
if the target memory region overlaps with the source.</p>
<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>
<pre><code class="lang-js"><span class="hljs-function_or_atom">const</span> <span class="hljs-function_or_atom">buf1</span> = <span class="hljs-variable">Buffer</span>.<span class="hljs-function_or_atom">allocUnsafe</span>(<span class="hljs-number">26</span>);
<span class="hljs-function_or_atom">const</span> <span class="hljs-function_or_atom">buf2</span> = <span class="hljs-variable">Buffer</span>.<span class="hljs-function_or_atom">allocUnsafe</span>(<span class="hljs-number">26</span>).<span class="hljs-function_or_atom">fill</span>(<span class="hljs-string">'!'</span>);

<span class="hljs-function_or_atom">for</span> (<span class="hljs-function_or_atom">let</span> <span class="hljs-function_or_atom">i</span> = <span class="hljs-number">0</span> ; <span class="hljs-function_or_atom">i</span> &lt; <span class="hljs-number">26</span> ; <span class="hljs-function_or_atom">i</span>++) {
  <span class="hljs-function_or_atom">buf1</span>[<span class="hljs-function_or_atom">i</span>] = <span class="hljs-function_or_atom">i</span> + <span class="hljs-number">97</span>; // <span class="hljs-number">97</span> <span class="hljs-function_or_atom">is</span> <span class="hljs-variable">ASCII</span> <span class="hljs-function_or_atom">a</span>
}

<span class="hljs-function_or_atom">buf1</span>.<span class="hljs-function_or_atom">copy</span>(<span class="hljs-function_or_atom">buf2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>);
<span class="hljs-function_or_atom">console</span>.<span class="hljs-function_or_atom">log</span>(<span class="hljs-function_or_atom">buf2</span>.<span class="hljs-function_or_atom">toString</span>(<span class="hljs-string">'ascii'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>));
  // <span class="hljs-variable">Prints</span>: <span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-function_or_atom">qrst</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span>
</code></pre>
<p>Example: Build a single Buffer, then copy data from one region to an overlapping
region in the same Buffer</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  buf[i] = i + <span class="hljs-number">97</span>; <span class="hljs-comment">// 97 is ASCII a</span>
}

buf.copy(buf, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);
console.<span class="hljs-built_in">log</span>(buf.toString());

<span class="hljs-comment">// efghijghijklmnopqrstuvwxyz</span>
</code></pre>
<h3 id="buf-entries-">buf.entries()</h3>
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="nofollow">iterator</a> of <code>[index, byte]</code> pairs from the Buffer
contents.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">'buffer'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">of</span> buf.entries()) {
  <span class="hljs-built_in">console</span>.log(pair);
}
<span class="hljs-comment">// prints:</span>
<span class="hljs-comment">//   [0, 98]</span>
<span class="hljs-comment">//   [1, 117]</span>
<span class="hljs-comment">//   [2, 102]</span>
<span class="hljs-comment">//   [3, 102]</span>
<span class="hljs-comment">//   [4, 101]</span>
<span class="hljs-comment">//   [5, 114]</span>
</code></pre>
<h3 id="buf-equals-otherbuffer-">buf.equals(otherBuffer)</h3>
<ul>
<li><code>otherBuffer</code> {Buffer}</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns a boolean indicating whether <code>this</code> and <code>otherBuffer</code> have exactly the
same bytes.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'ABC'</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'414243'</span>, <span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> buf3 = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'ABCD'</span>);

console.log(buf1.<span class="hljs-keyword">equals</span>(buf2));
  <span class="hljs-comment">// Prints: true</span>
console.log(buf1.<span class="hljs-keyword">equals</span>(buf3));
  <span class="hljs-comment">// Prints: false</span>
</code></pre>
<h3 id="buf-fill-value-offset-end-encoding-">buf.fill(value[, offset[, end]][, encoding])</h3>
<ul>
<li><code>value</code> {String|Buffer|Number}</li>
<li><code>offset</code> {Number} Default: 0</li>
<li><code>end</code> {Number} Default: <code>buf.length</code></li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li>Return: {Buffer}</li>
</ul>
<p>Fills the Buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buf.length</code>) are not given the entire buffer will be
filled. The method returns a reference to the Buffer, so calls can be chained.
This is meant as a small simplification to creating a Buffer. Allowing the
creation and fill of the Buffer to be done on a single line:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> b = Buffer.allocUnsafe(<span class="hljs-number">50</span>).fill(<span class="hljs-string">'h'</span>);
console.<span class="hljs-built_in">log</span>(b.toString());
  <span class="hljs-comment">// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</span>
</code></pre>
<p><code>encoding</code> is only relevant if <code>value</code> is a string. Otherwise it is ignored.
<code>value</code> is coerced to a <code>uint32</code> value if it is not a String or Number.</p>
<p>The <code>fill()</code> operation writes bytes into the Buffer dumbly. If the final write
falls in between a multi-byte character then whatever bytes fit into the buffer
are written.</p>
<pre><code class="lang-js"><span class="hljs-keyword">Buffer(3).fill('\u0222');
</span>  // Prints: &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-literal">c8</span> <span class="hljs-literal">a2</span> <span class="hljs-literal">c8</span>&gt;
</code></pre>
<h3 id="buf-indexof-value-byteoffset-encoding-">buf.indexOf(value[, byteOffset][, encoding])</h3>
<ul>
<li><code>value</code> {String|Buffer|Number}</li>
<li><code>byteOffset</code> {Number} Default: 0</li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li>Return: {Number}</li>
</ul>
<p>Operates similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="nofollow"><code>Array#indexOf()</code></a> in that it returns either the
starting index position of <code>value</code> in Buffer or <code>-1</code> if the Buffer does not
contain <code>value</code>. The <code>value</code> can be a String, Buffer or Number. Strings are by
default interpreted as UTF8. Buffers will use the entire Buffer (to compare a
partial Buffer use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>).  Numbers can range from 0 to 255.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'this is a buffer'</span>);

buf.indexOf(<span class="hljs-string">'this'</span>);
  <span class="hljs-comment">// returns 0</span>
buf.indexOf(<span class="hljs-string">'is'</span>);
  <span class="hljs-comment">// returns 2</span>
buf.indexOf(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer'</span>));
  <span class="hljs-comment">// returns 8</span>
buf.indexOf(<span class="hljs-number">97</span>); <span class="hljs-comment">// ascii for 'a'</span>
  <span class="hljs-comment">// returns 8</span>
buf.indexOf(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer example'</span>));
  <span class="hljs-comment">// returns -1</span>
buf.indexOf(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer example'</span>).slice(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>));
  <span class="hljs-comment">// returns 8</span>

<span class="hljs-keyword">const</span> utf16Buffer = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'\u039a\u0391\u03a3\u03a3\u0395'</span>, <span class="hljs-string">'ucs2'</span>);

utf16Buffer.indexOf(<span class="hljs-string">'\u03a3'</span>,  <span class="hljs-number">0</span>, <span class="hljs-string">'ucs2'</span>);
  <span class="hljs-comment">// returns 4</span>
utf16Buffer.indexOf(<span class="hljs-string">'\u03a3'</span>, -<span class="hljs-number">4</span>, <span class="hljs-string">'ucs2'</span>);
  <span class="hljs-comment">// returns 6</span>
</code></pre>
<h3 id="buf-includes-value-byteoffset-encoding-">buf.includes(value[, byteOffset][, encoding])</h3>
<ul>
<li><code>value</code> {String|Buffer|Number}</li>
<li><code>byteOffset</code> {Number} Default: 0</li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li>Return: {Boolean}</li>
</ul>
<p>Operates similar to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" target="_blank" rel="nofollow"><code>Array#includes()</code></a>. The <code>value</code> can be a String, Buffer
or Number. Strings are interpreted as UTF8 unless overridden with the
<code>encoding</code> argument. Buffers will use the entire Buffer (to compare a partial
Buffer use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>). Numbers can range from 0 to 255.</p>
<p>The <code>byteOffset</code> indicates the index in <code>buf</code> where searching begins.</p>
<pre><code class="lang-js">const buf = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'this is a buffer'</span>);

buf.<span class="hljs-keyword">includes</span>(<span class="hljs-string">'this'</span>);
  <span class="hljs-comment">// returns true</span>
buf.<span class="hljs-keyword">includes</span>(<span class="hljs-string">'is'</span>);
  <span class="hljs-comment">// returns true</span>
buf.<span class="hljs-keyword">includes</span>(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer'</span>));
  <span class="hljs-comment">// returns true</span>
buf.<span class="hljs-keyword">includes</span>(<span class="hljs-number">97</span>); <span class="hljs-comment">// ascii for 'a'</span>
  <span class="hljs-comment">// returns true</span>
buf.<span class="hljs-keyword">includes</span>(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer example'</span>));
  <span class="hljs-comment">// returns false</span>
buf.<span class="hljs-keyword">includes</span>(Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'a buffer example'</span>).slice(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>));
  <span class="hljs-comment">// returns true</span>
buf.<span class="hljs-keyword">includes</span>(<span class="hljs-string">'this'</span>, <span class="hljs-number">4</span>);
  <span class="hljs-comment">// returns false</span>
</code></pre>
<h3 id="buf-keys-">buf.keys()</h3>
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="nofollow">iterator</a> of Buffer keys (indices).</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">'buffer'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">of</span> buf.keys()) {
  <span class="hljs-built_in">console</span>.log(key);
}
<span class="hljs-comment">// prints:</span>
<span class="hljs-comment">//   0</span>
<span class="hljs-comment">//   1</span>
<span class="hljs-comment">//   2</span>
<span class="hljs-comment">//   3</span>
<span class="hljs-comment">//   4</span>
<span class="hljs-comment">//   5</span>
</code></pre>
<h3 id="buf-length">buf.length</h3>
<ul>
<li>{Number}</li>
</ul>
<p>Returns the amount of memory allocated for the Buffer in number of bytes. Note
that this does not necessarily reflect the amount of usable data within the
Buffer. For instance, in the example below, a Buffer with 1234 bytes is
allocated, but only 11 ASCII bytes are written.</p>
<pre><code class="lang-js">const buf = Buffer.alloc(<span class="hljs-number">1234</span>);

console.<span class="hljs-built_in">log</span>(buf.length);
  // <span class="hljs-keyword">Print</span><span class="hljs-variable">s:</span> <span class="hljs-number">1234</span>

buf.<span class="hljs-keyword">write</span>(<span class="hljs-string">'some string'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'ascii'</span>);
console.<span class="hljs-built_in">log</span>(buf.length);
  // <span class="hljs-keyword">Print</span><span class="hljs-variable">s:</span> <span class="hljs-number">1234</span>
</code></pre>
<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a Buffer should therefore treat <code>length</code> as read-only and
use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new Buffer.</p>
<pre><code class="lang-js">var buf = Buffer.allocUnsafe(<span class="hljs-number">10</span>);
buf.<span class="hljs-keyword">write</span>(<span class="hljs-string">'abcdefghj'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'ascii'</span>);
console.<span class="hljs-built_in">log</span>(buf.length);
  // <span class="hljs-keyword">Print</span><span class="hljs-variable">s:</span> <span class="hljs-number">10</span>
buf = buf.slice(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);
console.<span class="hljs-built_in">log</span>(buf.length);
  // <span class="hljs-keyword">Print</span><span class="hljs-variable">s:</span> <span class="hljs-number">5</span>
</code></pre>
<h3 id="buf-readdoublebe-offset-noassert-">buf.readDoubleBE(offset[, noAssert])</h3>
<h3 id="buf-readdoublele-offset-noassert-">buf.readDoubleLE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads a 64-bit double from the Buffer at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]);

buf.readDoubleBE();
  <span class="hljs-comment">// Returns: 8.20788039913184e-304</span>
buf.readDoubleLE();
  <span class="hljs-comment">// Returns: 5.447603722011605e-270</span>
buf.readDoubleLE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// throws RangeError: Index out of range</span>

buf.readDoubleLE(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// Warning: reads passed end of buffer!</span>
  <span class="hljs-comment">// Segmentation fault! don't do this!</span>
</code></pre>
<h3 id="buf-readfloatbe-offset-noassert-">buf.readFloatBE(offset[, noAssert])</h3>
<h3 id="buf-readfloatle-offset-noassert-">buf.readFloatLE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads a 32-bit float from the Buffer at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

buf.readFloatBE();
  <span class="hljs-comment">// Returns: 2.387939260590663e-38</span>
buf.readFloatLE();
  <span class="hljs-comment">// Returns: 1.539989614439558e-36</span>
buf.readFloatLE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// throws RangeError: Index out of range</span>

buf.readFloatLE(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// Warning: reads passed end of buffer!</span>
  <span class="hljs-comment">// Segmentation fault! don't do this!</span>
</code></pre>
<h3 id="buf-readint8-offset-noassert-">buf.readInt8(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads a signed 8-bit integer from the Buffer at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

buf.readInt8(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// returns 1</span>
buf.readInt8(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// returns -2</span>
</code></pre>
<h3 id="buf-readint16be-offset-noassert-">buf.readInt16BE(offset[, noAssert])</h3>
<h3 id="buf-readint16le-offset-noassert-">buf.readInt16LE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads a signed 16-bit integer from the Buffer at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

buf.readInt16BE();
  <span class="hljs-comment">// returns 510</span>
buf.readInt16LE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// returns 1022</span>
</code></pre>
<h3 id="buf-readint32be-offset-noassert-">buf.readInt32BE(offset[, noAssert])</h3>
<h3 id="buf-readint32le-offset-noassert-">buf.readInt32LE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads a signed 32-bit integer from the Buffer at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<p>Integers read from the Buffer are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

buf.readInt32BE();
  <span class="hljs-comment">// returns 33424132</span>
buf.readInt32LE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// returns 67370497</span>
</code></pre>
<h3 id="buf-readintbe-offset-bytelength-noassert-">buf.readIntBE(offset, byteLength[, noAssert])</h3>
<h3 id="buf-readintle-offset-bytelength-noassert-">buf.readIntLE(offset, byteLength[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">6</span>);
buf.writeUInt16LE(<span class="hljs-number">0x90ab</span>, <span class="hljs-number">0</span>);
buf.writeUInt32LE(<span class="hljs-number">0x12345678</span>, <span class="hljs-number">2</span>);
buf.readIntLE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>);  <span class="hljs-comment">// Specify 6 bytes (48 bits)</span>
<span class="hljs-comment">// Returns: '1234567890ab'</span>

buf.readIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>);
<span class="hljs-comment">// Returns: -546f87a9cbee</span>
</code></pre>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<h3 id="buf-readuint8-offset-noassert-">buf.readUInt8(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads an unsigned 8-bit integer from the Buffer at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);

buf.readUInt8(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// returns 1</span>
buf.readUInt8(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// returns 254</span>
</code></pre>
<h3 id="buf-readuint16be-offset-noassert-">buf.readUInt16BE(offset[, noAssert])</h3>
<h3 id="buf-readuint16le-offset-noassert-">buf.readUInt16LE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads an unsigned 16-bit integer from the Buffer at the specified <code>offset</code> with
specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x42</span>]);

buf.readUInt16BE(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// Returns: 0x0304</span>
buf.readUInt16LE(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// Returns: 0x0403</span>
buf.readUInt16BE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// Returns: 0x0423</span>
buf.readUInt16LE(<span class="hljs-number">1</span>);
  <span class="hljs-comment">// Returns: 0x2304</span>
buf.readUInt16BE(<span class="hljs-number">2</span>);
  <span class="hljs-comment">// Returns: 0x2342</span>
buf.readUInt16LE(<span class="hljs-number">2</span>);
  <span class="hljs-comment">// Returns: 0x4223</span>
</code></pre>
<h3 id="buf-readuint32be-offset-noassert-">buf.readUInt32BE(offset[, noAssert])</h3>
<h3 id="buf-readuint32le-offset-noassert-">buf.readUInt32LE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads an unsigned 32-bit integer from the Buffer at the specified <code>offset</code> with
specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x23</span>, <span class="hljs-number">0x42</span>]);

buf.readUInt32BE(<span class="hljs-number">0</span>);
  <span class="hljs-comment">// Returns: 0x03042342</span>
console.<span class="hljs-built_in">log</span>(buf.readUInt32LE(<span class="hljs-number">0</span>));
  <span class="hljs-comment">// Returns: 0x42230403</span>
</code></pre>
<h3 id="buf-readuintbe-offset-bytelength-noassert-">buf.readUIntBE(offset, byteLength[, noAssert])</h3>
<h3 id="buf-readuintle-offset-bytelength-noassert-">buf.readUIntLE(offset, byteLength[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from the Buffer at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">6</span>);
buf.writeUInt16LE(<span class="hljs-number">0x90ab</span>, <span class="hljs-number">0</span>);
buf.writeUInt32LE(<span class="hljs-number">0x12345678</span>, <span class="hljs-number">2</span>);
buf.readUIntLE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>);  <span class="hljs-comment">// Specify 6 bytes (48 bits)</span>
<span class="hljs-comment">// Returns: '1234567890ab'</span>

buf.readUIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>);
<span class="hljs-comment">// Returns: ab9078563412</span>
</code></pre>
<p>Setting <code>noAssert</code> to <code>true</code> skips validation of the <code>offset</code>. This allows the
<code>offset</code> to be beyond the end of the Buffer.</p>
<h3 id="buf-slice-start-end-">buf.slice([start[, end]])</h3>
<ul>
<li><code>start</code> {Number} Default: 0</li>
<li><code>end</code> {Number} Default: <code>buffer.length</code></li>
<li>Return: {Buffer}</li>
</ul>
<p>Returns a new Buffer that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</p>
<p><strong>Note that modifying the new Buffer slice will modify the memory in the
original Buffer because the allocated memory of the two objects overlap.</strong></p>
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf1 </span>= <span class="hljs-keyword">Buffer.allocUnsafe(26);
</span>
<span class="hljs-label">for</span> (var i = <span class="hljs-number">0</span> <span class="hljs-comment">; i &lt; 26 ; i++) {</span>
  <span class="hljs-keyword">buf1[i] </span>= i + <span class="hljs-number">97</span><span class="hljs-comment">; // 97 is ASCII a</span>
}

<span class="hljs-label">const</span> <span class="hljs-keyword">buf2 </span>= <span class="hljs-keyword">buf1.slice(0, </span><span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
<span class="hljs-keyword">buf2.toString('ascii', </span><span class="hljs-number">0</span>, <span class="hljs-keyword">buf2.length);
</span>  // Returns: <span class="hljs-string">'abc'</span>
<span class="hljs-keyword">buf1[0] </span>= <span class="hljs-number">33</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">buf2.toString('ascii', </span><span class="hljs-number">0</span>, <span class="hljs-keyword">buf2.length);
</span>  // Returns : <span class="hljs-string">'!bc'</span>
</code></pre>
<p>Specifying negative indexes causes the slice to be generated relative to the
end of the Buffer rather than the beginning.</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf </span>= <span class="hljs-keyword">Buffer.from('buffer');
</span>
<span class="hljs-keyword">buf.slice(-6, </span>-<span class="hljs-number">1</span>).toString()<span class="hljs-comment">;</span>
  // Returns <span class="hljs-string">'buffe'</span>, equivalent to <span class="hljs-keyword">buf.slice(0, </span><span class="hljs-number">5</span>)
<span class="hljs-keyword">buf.slice(-6, </span>-<span class="hljs-number">2</span>).toString()<span class="hljs-comment">;</span>
  // Returns <span class="hljs-string">'buff'</span>, equivalent to <span class="hljs-keyword">buf.slice(0, </span><span class="hljs-number">4</span>)
<span class="hljs-keyword">buf.slice(-5, </span>-<span class="hljs-number">2</span>).toString()<span class="hljs-comment">;</span>
  // Returns <span class="hljs-string">'uff'</span>, equivalent to <span class="hljs-keyword">buf.slice(1, </span><span class="hljs-number">4</span>)
</code></pre>
<h3 id="buf-tostring-encoding-start-end-">buf.toString([encoding[, start[, end]]])</h3>
<ul>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li><code>start</code> {Number} Default: 0</li>
<li><code>end</code> {Number} Default: <code>buffer.length</code></li>
<li>Return: {String}</li>
</ul>
<p>Decodes and returns a string from the Buffer data using the specified
character set <code>encoding</code>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">26</span>)<span class="hljs-comment">;</span>
<span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span> <span class="hljs-comment">; i &lt; 26 ; i++) {</span>
  buf[i] = i + <span class="hljs-number">97</span><span class="hljs-comment">; // 97 is ASCII a</span>
}
buf.toString(<span class="hljs-string">'ascii'</span>)<span class="hljs-comment">;</span>
  // Returns: <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span>
buf.toString(<span class="hljs-string">'ascii'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
  // Returns: <span class="hljs-string">'abcde'</span>
buf.toString(<span class="hljs-string">'utf8'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
  // Returns: <span class="hljs-string">'abcde'</span>
buf.toString(undefined,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<span class="hljs-comment">;</span>
  // Returns: <span class="hljs-string">'abcde'</span>, encoding defaults <span class="hljs-keyword">to</span> <span class="hljs-string">'utf8'</span>
</code></pre>
<h3 id="buf-tojson-">buf.toJSON()</h3>
<ul>
<li>Return: {Object}</li>
</ul>
<p>Returns a JSON representation of the Buffer instance.  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="nofollow"><code>JSON.stringify()</code></a>
implicitly calls this function when stringifying a Buffer instance.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'test'</span>);
<span class="hljs-keyword">const</span> json = JSON.stringify(buf);

console.log(json);
<span class="hljs-comment">// Prints: '{"type":"Buffer","data":[116,101,115,116]}'</span>

<span class="hljs-keyword">const</span> copy = JSON.parse(json, (key, <span class="hljs-keyword">value</span>) =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> &amp;&amp; <span class="hljs-keyword">value</span>.type === <span class="hljs-string">'Buffer'</span>
      ? Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-keyword">value</span>.data)
      : <span class="hljs-keyword">value</span>;
  });

console.log(copy.toString());
<span class="hljs-comment">// Prints: 'test'</span>
</code></pre>
<h3 id="buf-values-">buf.values()</h3>
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="nofollow">iterator</a> for Buffer values (bytes). This function is
called automatically when the Buffer is used in a <code>for..of</code> statement.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.<span class="hljs-keyword">from</span>(<span class="hljs-string">'buffer'</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> of buf.values()) {
  console.log(<span class="hljs-keyword">value</span>);
}
<span class="hljs-comment">// prints:</span>
<span class="hljs-comment">//   98</span>
<span class="hljs-comment">//   117</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   101</span>
<span class="hljs-comment">//   114</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> of buf) {
  console.log(<span class="hljs-keyword">value</span>);
}
<span class="hljs-comment">// prints:</span>
<span class="hljs-comment">//   98</span>
<span class="hljs-comment">//   117</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   101</span>
<span class="hljs-comment">//   114</span>
</code></pre>
<h3 id="buf-write-string-offset-length-encoding-">buf.write(string[, offset[, length]][, encoding])</h3>
<ul>
<li><code>string</code> {String} Bytes to be written to buffer</li>
<li><code>offset</code> {Number} Default: 0</li>
<li><code>length</code> {Number} Default: <code>buffer.length - offset</code></li>
<li><code>encoding</code> {String} Default: <code>&#39;utf8&#39;</code></li>
<li>Return: {Number} Numbers of bytes written</li>
</ul>
<p>Writes <code>string</code> to the Buffer at <code>offset</code> using the given <code>encoding</code>.
The <code>length</code> parameter is the number of bytes to write. If the Buffer did not
contain enough space to fit the entire string, only a partial amount of the
string will be written however, it will not write only partially encoded
characters.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">256</span>);
<span class="hljs-keyword">const</span> len = buf.write(<span class="hljs-string">'\u00bd + \u00bc = \u00be'</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${len}</span> bytes: <span class="hljs-subst">${buf.toString('utf8', 0, len)}</span>`</span>);
  <span class="hljs-comment">// Prints: 12 bytes: ½ + ¼ = ¾</span>
</code></pre>
<h3 id="buf-writedoublebe-value-offset-noassert-">buf.writeDoubleBE(value, offset[, noAssert])</h3>
<h3 id="buf-writedoublele-value-offset-noassert-">buf.writeDoubleLE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). The <code>value</code> argument must be a valid 64-bit double.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf </span>= <span class="hljs-keyword">Buffer.allocUnsafe(8);
</span><span class="hljs-keyword">buf.writeDoubleBE(0xdeadbeefcafebabe, </span><span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

<span class="hljs-label">console.log</span>(<span class="hljs-keyword">buf);
</span>  // Prints: &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-number">43</span> eb <span class="hljs-literal">d5</span> <span class="hljs-keyword">b7 </span>dd f9 <span class="hljs-number">5</span>f <span class="hljs-literal">d7</span>&gt;

<span class="hljs-keyword">buf.writeDoubleLE(0xdeadbeefcafebabe, </span><span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

<span class="hljs-label">console.log</span>(<span class="hljs-keyword">buf);
</span>  // Prints: &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-literal">d7</span> <span class="hljs-number">5</span>f f9 dd <span class="hljs-keyword">b7 </span><span class="hljs-literal">d5</span> eb <span class="hljs-number">43</span>&gt;
</code></pre>
<h3 id="buf-writefloatbe-value-offset-noassert-">buf.writeFloatBE(value, offset[, noAssert])</h3>
<h3 id="buf-writefloatle-value-offset-noassert-">buf.writeFloatLE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). Behavior is unspecified if <code>value</code> is anything other than a 32-bit
float.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-label">const</span> <span class="hljs-keyword">buf </span>= <span class="hljs-keyword">Buffer.allocUnsafe(4);
</span><span class="hljs-keyword">buf.writeFloatBE(0xcafebabe, </span><span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

<span class="hljs-label">console.log</span>(<span class="hljs-keyword">buf);
</span>  // Prints: &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-number">4</span>f <span class="hljs-number">4</span>a fe <span class="hljs-keyword">bb&gt;
</span>
<span class="hljs-keyword">buf.writeFloatLE(0xcafebabe, </span><span class="hljs-number">0</span>)<span class="hljs-comment">;</span>

<span class="hljs-label">console.log</span>(<span class="hljs-keyword">buf);
</span>  // Prints: &lt;<span class="hljs-keyword">Buffer </span><span class="hljs-keyword">bb </span>fe <span class="hljs-number">4</span>a <span class="hljs-number">4</span>f&gt;
</code></pre>
<h3 id="buf-writeint8-value-offset-noassert-">buf.writeInt8(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> must be a
valid signed 8-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">2</span>);
buf.writeInt8(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
buf.writeInt8(-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 02 fe&gt;</span>
</code></pre>
<h3 id="buf-writeint16be-value-offset-noassert-">buf.writeInt16BE(value, offset[, noAssert])</h3>
<h3 id="buf-writeint16le-value-offset-noassert-">buf.writeInt16LE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). The <code>value</code> must be a valid signed 16-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);
buf.writeInt16BE(<span class="hljs-number">0x0102</span>,<span class="hljs-number">0</span>);
buf.writeInt16LE(<span class="hljs-number">0x0304</span>,<span class="hljs-number">2</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 01 02 04 03&gt;</span>
</code></pre>
<h3 id="buf-writeint32be-value-offset-noassert-">buf.writeInt32BE(value, offset[, noAssert])</h3>
<h3 id="buf-writeint32le-value-offset-noassert-">buf.writeInt32LE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). The <code>value</code> must be a valid signed 32-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>The <code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">8</span>);
buf.writeInt32BE(<span class="hljs-number">0x01020304</span>,<span class="hljs-number">0</span>);
buf.writeInt32LE(<span class="hljs-number">0x05060708</span>,<span class="hljs-number">4</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;</span>
</code></pre>
<h3 id="buf-writeintbe-value-offset-bytelength-noassert-">buf.writeIntBE(value, offset, byteLength[, noAssert])</h3>
<h3 id="buf-writeintle-value-offset-bytelength-noassert-">buf.writeIntLE(value, offset, byteLength[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.
Supports up to 48 bits of accuracy. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.allocUnsafe(<span class="hljs-number">6</span>);
buf1.writeUIntBE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
console.<span class="hljs-built_in">log</span>(buf1);
  <span class="hljs-comment">// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>

<span class="hljs-keyword">const</span> buf2 = Buffer.allocUnsafe(<span class="hljs-number">6</span>);
buf2.writeUIntLE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
console.<span class="hljs-built_in">log</span>(buf2);
  <span class="hljs-comment">// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</span>
</code></pre>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<h3 id="buf-writeuint8-value-offset-noassert-">buf.writeUInt8(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code>. The <code>value</code> must be a
valid unsigned 8-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);
buf.writeUInt8(<span class="hljs-number">0x3</span>, <span class="hljs-number">0</span>);
buf.writeUInt8(<span class="hljs-number">0x4</span>, <span class="hljs-number">1</span>);
buf.writeUInt8(<span class="hljs-number">0x23</span>, <span class="hljs-number">2</span>);
buf.writeUInt8(<span class="hljs-number">0x42</span>, <span class="hljs-number">3</span>);

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 03 04 23 42&gt;</span>
</code></pre>
<h3 id="buf-writeuint16be-value-offset-noassert-">buf.writeUInt16BE(value, offset[, noAssert])</h3>
<h3 id="buf-writeuint16le-value-offset-noassert-">buf.writeUInt16LE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). The <code>value</code> must be a valid unsigned 16-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);
buf.writeUInt16BE(<span class="hljs-number">0xdead</span>, <span class="hljs-number">0</span>);
buf.writeUInt16BE(<span class="hljs-number">0xbeef</span>, <span class="hljs-number">2</span>);

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer de ad be ef&gt;</span>

buf.writeUInt16LE(<span class="hljs-number">0xdead</span>, <span class="hljs-number">0</span>);
buf.writeUInt16LE(<span class="hljs-number">0xbeef</span>, <span class="hljs-number">2</span>);

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer ad de ef be&gt;</span>
</code></pre>
<h3 id="buf-writeuint32be-value-offset-noassert-">buf.writeUInt32BE(value, offset[, noAssert])</h3>
<h3 id="buf-writeuint32le-value-offset-noassert-">buf.writeUInt32LE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). The <code>value</code> must be a valid unsigned 32-bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);
buf.writeUInt32BE(<span class="hljs-number">0xfeedface</span>, <span class="hljs-number">0</span>);

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer fe ed fa ce&gt;</span>

buf.writeUInt32LE(<span class="hljs-number">0xfeedface</span>, <span class="hljs-number">0</span>);

console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer ce fa ed fe&gt;</span>
</code></pre>
<h3 id="buf-writeuintbe-value-offset-bytelength-noassert-">buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3>
<h3 id="buf-writeuintle-value-offset-bytelength-noassert-">buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to Buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number} The offset plus the number of written bytes</li>
</ul>
<p>Writes <code>value</code> to the Buffer at the specified <code>offset</code> and <code>byteLength</code>.
Supports up to 48 bits of accuracy. For example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">6</span>);
buf.writeUIntBE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
console.<span class="hljs-built_in">log</span>(buf);
  <span class="hljs-comment">// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>
</code></pre>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the Buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness.</p>
<h2 id="buffer-inspect_max_bytes">buffer.INSPECT_MAX_BYTES</h2>
<ul>
<li>{Number} Default: 50</li>
</ul>
<p>Returns the maximum number of bytes that will be returned when
<code>buffer.inspect()</code> is called. This can be overridden by user modules. See
<a href="util.html#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buffer.inspect()</code> behavior.</p>
<p>Note that this is a property on the <code>buffer</code> module as returned by
<code>require(&#39;buffer&#39;)</code>, not on the Buffer global or a Buffer instance.</p>
<h2 id="class-slowbuffer">Class: SlowBuffer</h2>
<p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated Buffers, by default allocations under 4KB are sliced from a single
larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time, it may be appropriate to create an
un-pooled Buffer instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>
<pre><code class="lang-js"><span class="hljs-comment">// need to keep around a few small chunks of memory</span>
<span class="hljs-keyword">const</span> store = [];

socket.<span class="hljs-keyword">on</span>('readable', () =&gt; {
  <span class="hljs-keyword">var</span> data = socket.<span class="hljs-keyword">read</span>();
  <span class="hljs-comment">// allocate for retained data</span>
  <span class="hljs-keyword">var</span> sb = SlowBuffer(10);
  <span class="hljs-comment">// copy the data into the new allocation</span>
  data.<span class="hljs-keyword">copy</span>(sb, 0, 0, 10);
  store.push(sb);
});
</code></pre>
<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer
has observed undue memory retention in their applications.</p>
<h3 id="new-slowbuffer-size-">new SlowBuffer(size)</h3>
<ul>
<li><code>size</code> Number</li>
</ul>
<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than
or equal to the value of <code>require(&#39;buffer&#39;).kMaxLength</code> (on 64-bit
architectures, <code>kMaxLength</code> is <code>(2^31)-1</code>). Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is
thrown. If a <code>size</code> less than 0 is specified, a zero-length <code>SlowBuffer</code> will be
created.</p>
<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The
contents of a newly created <code>SlowBuffer</code> are unknown and could contain
sensitive data. Use <a href="#buffer_buf_fill_value_offset_end"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> SlowBuffer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'buffer'</span>).SlowBuffer;
<span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> SlowBuffer(<span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(buf);
  <span class="hljs-comment">// &lt;Buffer 78 e0 82 02 01&gt;</span>
  <span class="hljs-comment">// (octets will be different, every time)</span>
buf.fill(<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(buf);
  <span class="hljs-comment">// &lt;Buffer 00 00 00 00 00&gt;</span>
</code></pre>


          </section>
        </div>
      </div>
    </div>
    <script src="../assets/js/vendor/jquery.js"></script>
    <script src="../assets/js/vendor/fastclick.js"></script>
    <script src="../assets/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
  </html>