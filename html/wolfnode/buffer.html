<!DOCTYPE html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>WolfScript API buffer</title>

  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link href="..\assets\css\docs.css" rel="stylesheet" />
  <link href="..\assets\css\github.css" rel="stylesheet" />
  <link href="..\assets\fonts\foundation-icons.css" rel="stylesheet" />
   <script src="..\assets\js\vendor\modernizr.js"></script>
</head>
<body>
  <body class="antialiased hide-extras">
    <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a href="http://miningwolf.com/"><i class="fi-paw"></i> Mining Wolf</a></h1>
    </li>
  </ul>

  <section class="top-bar-section">
    <ul class="right">
      <li class="divider"></li>
         <li class='divider'></li>
<li><a href='..\index.html' class=''>Home</a></li>
<li class='divider'></li>
<li><a href='..\wolfbuk\io\wolfscript\0.html' class=''>WolfBuk API</a></li>
<li class='divider'></li>
<li><a href='..\wolfcanary\io\wolfscript\0.html' class=''>WolfCanary API</a></li>
<li class='divider'></li>
<li><a href='..\wolfnode\globals.html' class=''>WolfNode</a></li>

       <li class="divider"></li>
       <li><a href='http://github.com/miningwolf/wolfscript ' class=''> <i class="fi-social-github"></i> Github</a></li>
       <li class="divider"></li>
       <li class="has-form">
       <a href="..\GettingStarted.html " class="small button">Getting Started</a>
       </li>
    </ul>
  </section>
</nav>
<ul class="breadcrumbs">
<li><a href='..\index.html'>Home </a></li>
 <li><a href='..\wolfnode\globals.html'>wolfnode</a></li>
<li class='current'><a href='#'>buffer</a></li>

</ul>

      <div class="row">
        <div class="large-3 medium-4 columns">
          <div class="hide-for-small">
            <div class="sidebar">
              <nav>
                <ul class="side-nav accordion" data-accordion>
                  <li class='heading'><a href='..\wolfnode\globals.html' class=''>WolfNode</a></li> 
<li class='divider'></li>
<li class='heading'><a href='..\wolfnode\buffer.html' class=''>Core</a></li> 
<li class='active'><a href='..\wolfnode\buffer.html'>buffer</a></li>
<li><a href='..\wolfnode\console.html'>console</a></li>
<li><a href='..\wolfnode\crypto.html'>crypto</a></li>
<li><a href='..\wolfnode\dgram.html'>dgram</a></li>
<li><a href='..\wolfnode\dns.html'>dns</a></li>
<li><a href='..\wolfnode\events.html'>events</a></li>
<li><a href='..\wolfnode\fs.html'>fs</a></li>
<li><a href='..\wolfnode\http.html'>http</a></li>
<li><a href='..\wolfnode\https.html'>https</a></li>
<li><a href='..\wolfnode\net.html'>net</a></li>
<li><a href='..\wolfnode\path.html'>path</a></li>
<li><a href='..\wolfnode\process.html'>process</a></li>
<li><a href='..\wolfnode\querystring.html'>querystring</a></li>
<li><a href='..\wolfnode\stream.html'>stream</a></li>
<li><a href='..\wolfnode\timers.html'>timers</a></li>
<li><a href='..\wolfnode\tls.html'>tls</a></li>
<li><a href='..\wolfnode\url.html'>url</a></li>
<li><a href='..\wolfnode\util.html'>util</a></li>
<li class='divider'></li>
<li class='heading'><a href='..\wolfnode\assert.html' class=''>Other</a></li> 
<li class='divider'></li>

                  </ul>
              </nav>
            </div>
          </div>
        </div>
        <div class="large-9 medium-8 columns">
          <section class="doc-content">
            <h1 id="buffer">Buffer</h1>
<pre><code><span class="hljs-attribute">Stability</span>: <span class="hljs-string">3 - Stable</span>
</code></pre><p>Pure JavaScript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it&#39;s necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>
<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.</p>
<p>The <code>Buffer</code> class is a global, making it very rare that one would need
to ever <code>require(&#39;buffer&#39;)</code>.</p>
<p>Converting between Buffers and JavaScript string objects requires an explicit
encoding method.  Here are the different string encodings.</p>
<ul>
<li><p><code>&#39;ascii&#39;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and
will strip the high bit if set.</p>
</li>
<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>
</li>
<li><p><code>&#39;base64&#39;</code> - Base64 string encoding.</p>
</li>
<li><p><code>&#39;binary&#39;</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p>
</li>
<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p>Creating a typed array from a <code>Buffer</code> works with the following caveats:</p>
<ol>
<li><p>The buffer&#39;s memory is copied, not shared.</p>
</li>
<li><p>The buffer&#39;s memory is interpreted as an array, not a byte array.  That is,
<code>new Uint32Array(new Buffer([1,2,3,4]))</code> creates a 4-element <code>Uint32Array</code>
with elements <code>[1,2,3,4]</code>, not an <code>Uint32Array</code> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol>
<p>NOTE: Node.js v0.8 simply retained a reference to the buffer in <code>array.buffer</code>
instead of cloning it.</p>
<p>While more efficient, it introduces subtle incompatibilities with the typed
arrays specification.  <code>ArrayBuffer#slice()</code> makes a copy of the slice while
<code>Buffer#slice()</code> creates a view.</p>
<h2 id="class-buffer">Class: Buffer</h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>
<h3 id="new-buffer-size-">new Buffer(size)</h3>
<ul>
<li><code>size</code> Number</li>
</ul>
<p>Allocates a new buffer of <code>size</code> octets. Note, <code>size</code> must be no more than
<a href="smalloc.html#smalloc_smalloc_kmaxlength">kMaxLength</a>. Otherwise, a <code>RangeError</code>
will be thrown here.</p>
<h3 id="new-buffer-array-">new Buffer(array)</h3>
<ul>
<li><code>array</code> Array</li>
</ul>
<p>Allocates a new buffer using an <code>array</code> of octets.</p>
<h3 id="new-buffer-buffer-">new Buffer(buffer)</h3>
<ul>
<li><code>buffer</code> {Buffer}</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<h3 id="new-buffer-str-encoding-">new Buffer(str[, encoding])</h3>
<ul>
<li><code>str</code> String - string to encode.</li>
<li><code>encoding</code> String - encoding to use, Optional.</li>
</ul>
<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.</p>
<h3 id="class-method-buffer-isencoding-encoding-">Class Method: Buffer.isEncoding(encoding)</h3>
<ul>
<li><code>encoding</code> {String} The encoding string to test</li>
</ul>
<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false
otherwise.</p>
<h3 id="class-method-buffer-isbuffer-obj-">Class Method: Buffer.isBuffer(obj)</h3>
<ul>
<li><code>obj</code> Object</li>
<li>Return: Boolean</li>
</ul>
<p>Tests if <code>obj</code> is a <code>Buffer</code>.</p>
<h3 id="class-method-buffer-bytelength-string-encoding-">Class Method: Buffer.byteLength(string[, encoding])</h3>
<ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
<li>Return: Number</li>
</ul>
<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.
This is not the same as <code>String.prototype.length</code> since that returns the
number of <em>characters</em> in a string.</p>
<p>Example:</p>
<pre><code><span class="hljs-built_in">str</span> = <span class="hljs-string">'\u00bd + \u00bc = \u00be'</span>;

console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span> + <span class="hljs-string">": "</span> + <span class="hljs-built_in">str</span>.length + <span class="hljs-string">" characters, "</span> +
  Buffer.byteLength(<span class="hljs-built_in">str</span>, <span class="hljs-string">'utf8'</span>) + <span class="hljs-string">" bytes"</span>);

<span class="hljs-comment">// ½ + ¼ = ¾: 9 characters, 12 bytes</span>
</code></pre><h3 id="class-method-buffer-concat-list-totallength-">Class Method: Buffer.concat(list[, totalLength])</h3>
<ul>
<li><code>list</code> {Array} List of Buffer objects to concat</li>
<li><code>totalLength</code> {Number} Total length of the buffers when concatenated</li>
</ul>
<p>Returns a buffer which is the result of concatenating all the buffers in
the list together.</p>
<p>If the list has no items, or if the totalLength is 0, then it returns a
zero-length buffer.</p>
<p>If the list has exactly one item, then the first item of the list is
returned.</p>
<p>If the list has more than one item, then a new Buffer is created.</p>
<p>If totalLength is not provided, it is read from the buffers in the list.
However, this adds an additional loop to the function, so it is faster
to provide the length explicitly.</p>
<h3 id="class-method-buffer-compare-buf1-buf2-">Class Method: Buffer.compare(buf1, buf2)</h3>
<ul>
<li><code>buf1</code> {Buffer}</li>
<li><code>buf2</code> {Buffer}</li>
</ul>
<p>The same as <a href="#buffer_buf_compare_otherbuffer"><code>buf1.compare(buf2)</code></a>. Useful
for sorting an Array of Buffers:</p>
<pre><code><span class="hljs-keyword">var</span> arr = [Buffer(<span class="hljs-string">'1234'</span>), Buffer(<span class="hljs-string">'0123'</span>)];
arr.sort(Buffer.compare);
</code></pre><h3 id="buf-length">buf.length</h3>
<ul>
<li>Number</li>
</ul>
<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.</p>
<pre><code>buf = new Buffer(<span class="hljs-number">1234</span>);

console.<span class="hljs-built_in">log</span>(buf.<span class="hljs-built_in">length</span>);
buf.write(<span class="hljs-string">"some string"</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"ascii"</span>);
console.<span class="hljs-built_in">log</span>(buf.<span class="hljs-built_in">length</span>);

<span class="hljs-comment">// 1234</span>
<span class="hljs-comment">// 1234</span>
</code></pre><p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a buffer should therefore treat <code>length</code> as read-only and
use <code>buf.slice</code> to create a new buffer.</p>
<pre><code><span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">10</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.write</span>(<span class="hljs-string">"abcdefghj"</span>, <span class="hljs-number">0</span>, <span class="hljs-string">"ascii"</span>);
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.length</span>); <span class="hljs-comment">// 10</span>
<span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> <span class="hljs-keyword">buf</span><span class="hljs-typename">.slice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.length</span>); <span class="hljs-comment">// 5</span>
</code></pre><h3 id="buf-write-string-offset-length-encoding-">buf.write(string[, offset][, length][, encoding])</h3>
<ul>
<li><code>string</code> String - data to be written to buffer</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional, Default: <code>buffer.length - offset</code></li>
<li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
</ul>
<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>. <code>length</code> is
the number of bytes to write. Returns number of octets written. If <code>buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.</p>
<pre><code>buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">256</span>);
<span class="hljs-built_in">len</span> = buf.<span class="hljs-keyword">write</span>(<span class="hljs-string">'\u00bd + \u00bc = \u00be'</span>, <span class="hljs-number">0</span>);
console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">len</span> + <span class="hljs-string">" bytes: "</span> + buf.toString(<span class="hljs-string">'utf8'</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>));
</code></pre><h3 id="buf-writeuintle-value-offset-bytelength-noassert-">buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3>
<h3 id="buf-writeuintbe-value-offset-bytelength-noassert-">buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3>
<h3 id="buf-writeintle-value-offset-bytelength-noassert-">buf.writeIntLE(value, offset, byteLength[, noAssert])</h3>
<h3 id="buf-writeintbe-value-offset-bytelength-noassert-">buf.writeIntBE(value, offset, byteLength[, noAssert])</h3>
<ul>
<li><code>value</code> {Number} Bytes to be written to buffer</li>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified <code>offset</code> and <code>byteLength</code>.
Supports up to 48 bits of accuracy. For example:</p>
<pre><code><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">6</span>);
b.writeUIntBE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);
<span class="hljs-comment">// &lt;Buffer 12 34 56 78 90 ab&gt;</span>
</code></pre><p>Set <code>noAssert</code> to <code>true</code> to skip validation of <code>value</code> and <code>offset</code>. Defaults
to <code>false</code>.</p>
<h3 id="buf-readuintle-offset-bytelength-noassert-">buf.readUIntLE(offset, byteLength[, noAssert])</h3>
<h3 id="buf-readuintbe-offset-bytelength-noassert-">buf.readUIntBE(offset, byteLength[, noAssert])</h3>
<h3 id="buf-readintle-offset-bytelength-noassert-">buf.readIntLE(offset, byteLength[, noAssert])</h3>
<h3 id="buf-readintbe-offset-bytelength-noassert-">buf.readIntBE(offset, byteLength[, noAssert])</h3>
<ul>
<li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length</code></li>
<li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Default: false</li>
<li>Return: {Number}</li>
</ul>
<p>A generalized version of all numeric read methods. Supports up to 48 bits of
accuracy. For example:</p>
<pre><code><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-type">Buffer</span>(<span class="hljs-number">6</span>);
b.writeUint16LE(<span class="hljs-number">0x90ab</span>, <span class="hljs-number">0</span>);
b.writeUInt32LE(<span class="hljs-number">0x12345678</span>, <span class="hljs-number">2</span>);
b.readUIntLE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).<span class="hljs-built_in">toString</span>(<span class="hljs-number">16</span>);  <span class="hljs-comment">// Specify 6 bytes (48 bits)</span>
<span class="hljs-comment">// output: '1234567890ab'</span>
</code></pre><p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<h3 id="buf-tostring-encoding-start-end-">buf.toString([encoding][, start][, end])</h3>
<ul>
<li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional, Default: <code>buffer.length</code></li>
</ul>
<p>Decodes and returns a string from buffer data encoded using the specified
character set encoding. If <code>encoding</code> is <code>undefined</code> or <code>null</code>, then <code>encoding</code>
defaults to <code>&#39;utf8&#39;. The</code>start<code>and</code>end<code>parameters default to</code>0<code>and</code>buffer.length<code>when</code>undefined`.</p>
<pre><code>buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">26</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  buf[i] = i + <span class="hljs-number">97</span>; <span class="hljs-comment">// 97 is ASCII a</span>
}
buf.toString(<span class="hljs-string">'ascii'</span>); <span class="hljs-comment">// outputs: abcdefghijklmnopqrstuvwxyz</span>
buf.toString(<span class="hljs-string">'ascii'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// outputs: abcde</span>
buf.toString(<span class="hljs-string">'utf8'</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// outputs: abcde</span>
buf.toString(<span class="hljs-literal">undefined</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">// encoding defaults to 'utf8', outputs abcde</span>
</code></pre><p>See <code>buffer.write()</code> example, above.</p>
<h3 id="buf-tojson-">buf.toJSON()</h3>
<p>Returns a JSON-representation of the Buffer instance.  <code>JSON.stringify</code>
implicitly calls this function when stringifying a Buffer instance.</p>
<p>Example:</p>
<pre><code><span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'test'</span>);
<span class="hljs-keyword">var</span> json = <span class="hljs-built_in">JSON</span>.stringify(buf);

<span class="hljs-built_in">console</span>.log(json);
<span class="hljs-comment">// '{"type":"Buffer","data":[116,101,115,116]}'</span>

<span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">JSON</span>.parse(json, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, value)</span> </span>{
    <span class="hljs-keyword">return</span> value &amp;&amp; value.type === <span class="hljs-string">'Buffer'</span>
      ? <span class="hljs-keyword">new</span> Buffer(value.data)
      : value;
  });

<span class="hljs-built_in">console</span>.log(copy);
<span class="hljs-comment">// &lt;Buffer 74 65 73 74&gt;</span>
</code></pre><h3 id="buf-index-">buf[index]</h3>
<!--type=property-->
<!--name=[index]-->
<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>
<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>
<pre><code><span class="hljs-built_in">str</span> = <span class="hljs-string">"node.js"</span>;
buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-built_in">str</span>.length);

<span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.length ; i++) {
  buf[i] = <span class="hljs-built_in">str</span>.charCodeAt(i);
}

console.<span class="hljs-built_in">log</span>(buf);

<span class="hljs-comment">// node.js</span>
</code></pre><h3 id="buf-equals-otherbuffer-">buf.equals(otherBuffer)</h3>
<ul>
<li><code>otherBuffer</code> {Buffer}</li>
</ul>
<p>Returns a boolean of whether <code>this</code> and <code>otherBuffer</code> have the same
bytes.</p>
<h3 id="buf-compare-otherbuffer-">buf.compare(otherBuffer)</h3>
<ul>
<li><code>otherBuffer</code> {Buffer}</li>
</ul>
<p>Returns a number indicating whether <code>this</code> comes before or after or is
the same as the <code>otherBuffer</code> in sort order.</p>
<h3 id="buf-copy-targetbuffer-targetstart-sourcestart-sourceend-">buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])</h3>
<ul>
<li><code>targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><code>sourceEnd</code> Number, Optional, Default: <code>buffer.length</code></li>
</ul>
<p>Copies data from a region of this buffer to a region in the target buffer even
if the target memory region overlaps with the source. If <code>undefined</code> the
<code>targetStart</code> and <code>sourceStart</code> parameters default to <code>0</code> while <code>sourceEnd</code>
defaults to <code>buffer.length</code>.</p>
<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>
<pre><code><span class="hljs-function_or_atom">buf1</span> = <span class="hljs-function_or_atom">new</span> <span class="hljs-variable">Buffer</span>(<span class="hljs-number">26</span>);
<span class="hljs-function_or_atom">buf2</span> = <span class="hljs-function_or_atom">new</span> <span class="hljs-variable">Buffer</span>(<span class="hljs-number">26</span>);

<span class="hljs-function_or_atom">for</span> (<span class="hljs-function_or_atom">var</span> <span class="hljs-function_or_atom">i</span> = <span class="hljs-number">0</span> ; <span class="hljs-function_or_atom">i</span> &lt; <span class="hljs-number">26</span> ; <span class="hljs-function_or_atom">i</span>++) {
  <span class="hljs-function_or_atom">buf1</span>[<span class="hljs-function_or_atom">i</span>] = <span class="hljs-function_or_atom">i</span> + <span class="hljs-number">97</span>; // <span class="hljs-number">97</span> <span class="hljs-function_or_atom">is</span> <span class="hljs-variable">ASCII</span> <span class="hljs-function_or_atom">a</span>
  <span class="hljs-function_or_atom">buf2</span>[<span class="hljs-function_or_atom">i</span>] = <span class="hljs-number">33</span>; // <span class="hljs-variable">ASCII</span> <span class="hljs-exclamation_mark">!</span>
}

<span class="hljs-function_or_atom">buf1</span>.<span class="hljs-function_or_atom">copy</span>(<span class="hljs-function_or_atom">buf2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>);
<span class="hljs-function_or_atom">console</span>.<span class="hljs-function_or_atom">log</span>(<span class="hljs-function_or_atom">buf2</span>.<span class="hljs-function_or_atom">toString</span>(<span class="hljs-string">'ascii'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>));

// <span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-function_or_atom">qrst</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span><span class="hljs-exclamation_mark">!</span>
</code></pre><p>Example: Build a single buffer, then copy data from one region to an overlapping
region in the same buffer</p>
<pre><code><span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (var i <span class="hljs-keyword">=</span> <span class="hljs-number">0</span> ; i <span class="hljs-keyword">&lt;</span> <span class="hljs-number">26</span> ; i<span class="hljs-keyword">+</span><span class="hljs-keyword">+</span>) <span class="hljs-keyword">{</span>
  <span class="hljs-keyword">buf</span>[i] <span class="hljs-keyword">=</span> i <span class="hljs-keyword">+</span> <span class="hljs-number">97</span>; <span class="hljs-comment">// 97 is ASCII a</span>
<span class="hljs-keyword">}</span>

<span class="hljs-keyword">buf</span><span class="hljs-typename">.copy</span>(<span class="hljs-keyword">buf</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.toString</span>());

<span class="hljs-comment">// efghijghijklmnopqrstuvwxyz</span>
</code></pre><h3 id="buf-slice-start-end-">buf.slice([start][, end])</h3>
<ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><code>end</code> Number, Optional, Default: <code>buffer.length</code></li>
</ul>
<p>Returns a new buffer which references the same memory as the old, but offset
and cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to
<code>buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.</p>
<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.</p>
<pre><code><span class="hljs-keyword">var</span> buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  buf1[i] = i + <span class="hljs-number">97</span>; <span class="hljs-comment">// 97 is ASCII a</span>
}

<span class="hljs-keyword">var</span> buf2 = buf1.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(buf2.toString(<span class="hljs-string">'ascii'</span>, <span class="hljs-number">0</span>, buf2.length));
buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">33</span>;
<span class="hljs-built_in">console</span>.log(buf2.toString(<span class="hljs-string">'ascii'</span>, <span class="hljs-number">0</span>, buf2.length));

<span class="hljs-comment">// abc</span>
<span class="hljs-comment">// !bc</span>
</code></pre><h3 id="buf-readuint8-offset-noassert-">buf.readUInt8(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);

<span class="hljs-keyword">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x3</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x4</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x23</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x42</span>;

<span class="hljs-keyword">for</span> (ii <span class="hljs-keyword">=</span> <span class="hljs-number">0</span>; ii <span class="hljs-keyword">&lt;</span> <span class="hljs-keyword">buf</span><span class="hljs-typename">.length</span>; ii<span class="hljs-keyword">+</span><span class="hljs-keyword">+</span>) <span class="hljs-keyword">{</span>
  console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt8</span>(ii));
<span class="hljs-keyword">}</span>

<span class="hljs-comment">// 0x3</span>
<span class="hljs-comment">// 0x4</span>
<span class="hljs-comment">// 0x23</span>
<span class="hljs-comment">// 0x42</span>
</code></pre><h3 id="buf-readuint16le-offset-noassert-">buf.readUInt16LE(offset[, noAssert])</h3>
<h3 id="buf-readuint16be-offset-noassert-">buf.readUInt16BE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);

<span class="hljs-keyword">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x3</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x4</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x23</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x42</span>;

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16BE</span>(<span class="hljs-number">0</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16LE</span>(<span class="hljs-number">0</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16BE</span>(<span class="hljs-number">1</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16LE</span>(<span class="hljs-number">1</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16BE</span>(<span class="hljs-number">2</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt16LE</span>(<span class="hljs-number">2</span>));

<span class="hljs-comment">// 0x0304</span>
<span class="hljs-comment">// 0x0403</span>
<span class="hljs-comment">// 0x0423</span>
<span class="hljs-comment">// 0x2304</span>
<span class="hljs-comment">// 0x2342</span>
<span class="hljs-comment">// 0x4223</span>
</code></pre><h3 id="buf-readuint32le-offset-noassert-">buf.readUInt32LE(offset[, noAssert])</h3>
<h3 id="buf-readuint32be-offset-noassert-">buf.readUInt32BE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);

<span class="hljs-keyword">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x3</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x4</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x23</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x42</span>;

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt32BE</span>(<span class="hljs-number">0</span>));
console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readUInt32LE</span>(<span class="hljs-number">0</span>));

<span class="hljs-comment">// 0x03042342</span>
<span class="hljs-comment">// 0x42230403</span>
</code></pre><h3 id="buf-readint8-offset-noassert-">buf.readInt8(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&#39;s
complement signed values.</p>
<h3 id="buf-readint16le-offset-noassert-">buf.readInt16LE(offset[, noAssert])</h3>
<h3 id="buf-readint16be-offset-noassert-">buf.readInt16BE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s
complement signed values.</p>
<h3 id="buf-readint32le-offset-noassert-">buf.readInt32LE(offset[, noAssert])</h3>
<h3 id="buf-readint32be-offset-noassert-">buf.readInt32BE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s
complement signed values.</p>
<h3 id="buf-readfloatle-offset-noassert-">buf.readFloatLE(offset[, noAssert])</h3>
<h3 id="buf-readfloatbe-offset-noassert-">buf.readFloatBE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);

<span class="hljs-keyword">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x00</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x00</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x80</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x3</span>f;

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readFloatLE</span>(<span class="hljs-number">0</span>));

<span class="hljs-comment">// 0x01</span>
</code></pre><h3 id="buf-readdoublele-offset-noassert-">buf.readDoubleLE(offset[, noAssert])</h3>
<h3 id="buf-readdoublebe-offset-noassert-">buf.readDoubleBE(offset[, noAssert])</h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li>Return: Number</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">8</span>);

<span class="hljs-keyword">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">4</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">5</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x55</span>;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">6</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x</span>d5;
<span class="hljs-keyword">buf</span>[<span class="hljs-number">7</span>] <span class="hljs-keyword">=</span> <span class="hljs-number">0x3</span>f;

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span><span class="hljs-typename">.readDoubleLE</span>(<span class="hljs-number">0</span>));

<span class="hljs-comment">// 0.3333333333333333</span>
</code></pre><h3 id="buf-writeuint8-value-offset-noassert-">buf.writeUInt8(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt8</span>(<span class="hljs-number">0x3</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt8</span>(<span class="hljs-number">0x4</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt8</span>(<span class="hljs-number">0x23</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt8</span>(<span class="hljs-number">0x42</span>, <span class="hljs-number">3</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-comment">// &lt;Buffer 03 04 23 42&gt;</span>
</code></pre><h3 id="buf-writeuint16le-value-offset-noassert-">buf.writeUInt16LE(value, offset[, noAssert])</h3>
<h3 id="buf-writeuint16be-value-offset-noassert-">buf.writeUInt16BE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt16BE</span>(<span class="hljs-number">0x</span>dead, <span class="hljs-number">0</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt16BE</span>(<span class="hljs-number">0x</span>beef, <span class="hljs-number">2</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt16LE</span>(<span class="hljs-number">0x</span>dead, <span class="hljs-number">0</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt16LE</span>(<span class="hljs-number">0x</span>beef, <span class="hljs-number">2</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-comment">// &lt;Buffer de ad be ef&gt;</span>
<span class="hljs-comment">// &lt;Buffer ad de ef be&gt;</span>
</code></pre><h3 id="buf-writeuint32le-value-offset-noassert-">buf.writeUInt32LE(value, offset[, noAssert])</h3>
<h3 id="buf-writeuint32be-value-offset-noassert-">buf.writeUInt32BE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt32BE</span>(<span class="hljs-number">0x</span>feedface, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeUInt32LE</span>(<span class="hljs-number">0x</span>feedface, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-comment">// &lt;Buffer fe ed fa ce&gt;</span>
<span class="hljs-comment">// &lt;Buffer ce fa ed fe&gt;</span>
</code></pre><h3 id="buf-writeint8-value-offset-noassert-">buf.writeInt8(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&#39;s complement
signed integer into <code>buffer</code>.</p>
<h3 id="buf-writeint16le-value-offset-noassert-">buf.writeInt16LE(value, offset[, noAssert])</h3>
<h3 id="buf-writeint16be-value-offset-noassert-">buf.writeInt16BE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&#39;s
complement signed integer into <code>buffer</code>.</p>
<h3 id="buf-writeint32le-value-offset-noassert-">buf.writeInt32LE(value, offset[, noAssert])</h3>
<h3 id="buf-writeint32be-value-offset-noassert-">buf.writeInt32BE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&#39;s
complement signed integer into <code>buffer</code>.</p>
<h3 id="buf-writefloatle-value-offset-noassert-">buf.writeFloatLE(value, offset[, noAssert])</h3>
<h3 id="buf-writefloatbe-value-offset-noassert-">buf.writeFloatBE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">4</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeFloatBE</span>(<span class="hljs-number">0x</span>cafebabe, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeFloatLE</span>(<span class="hljs-number">0x</span>cafebabe, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-comment">// &lt;Buffer 4f 4a fe bb&gt;</span>
<span class="hljs-comment">// &lt;Buffer bb fe 4a 4f&gt;</span>
</code></pre><h3 id="buf-writedoublele-value-offset-noassert-">buf.writeDoubleLE(value, offset[, noAssert])</h3>
<h3 id="buf-writedoublebe-value-offset-noassert-">buf.writeDoubleBE(value, offset[, noAssert])</h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.</p>
<p>Example:</p>
<pre><code>var <span class="hljs-keyword">buf</span> <span class="hljs-keyword">=</span> new Buffer(<span class="hljs-number">8</span>);
<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeDoubleBE</span>(<span class="hljs-number">0x</span>deadbeefcafebabe, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-keyword">buf</span><span class="hljs-typename">.writeDoubleLE</span>(<span class="hljs-number">0x</span>deadbeefcafebabe, <span class="hljs-number">0</span>);

console<span class="hljs-typename">.log</span>(<span class="hljs-keyword">buf</span>);

<span class="hljs-comment">// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;</span>
<span class="hljs-comment">// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</span>
</code></pre><h3 id="buf-fill-value-offset-end-">buf.fill(value[, offset][, end])</h3>
<ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><code>end</code> Number, Optional</li>
</ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.</p>
<pre><code><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">50</span>);
b.fill(<span class="hljs-string">"h"</span>);
</code></pre><h2 id="buffer-inspect_max_bytes">buffer.INSPECT_MAX_BYTES</h2>
<ul>
<li>Number, Default: 50</li>
</ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&#39;buffer&#39;)</code>, not on the Buffer global, or a buffer instance.</p>
<h2 id="class-slowbuffer">Class: SlowBuffer</h2>
<p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated Buffers, by default allocations under 4KB are sliced from a single
larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time it may be appropriate to create an
un-pooled Buffer instance using SlowBuffer and copy out the relevant bits.</p>
<pre><code><span class="hljs-comment">// need to keep around a few small chunks of memory</span>
<span class="hljs-keyword">var</span> store = [];

socket.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> data = socket.read();
  <span class="hljs-comment">// allocate for retained data</span>
  <span class="hljs-keyword">var</span> sb = <span class="hljs-keyword">new</span> SlowBuffer(<span class="hljs-number">10</span>);
  <span class="hljs-comment">// copy the data into the new allocation</span>
  data.copy(sb, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
  store.push(sb);
});
</code></pre><p>Though this should used sparingly and only be a last resort <em>after</em> a developer
has actively observed undue memory retention in their applications.</p>


          </section>
        </div>
      </div>
    </div>
    <script src="..\assets\js\vendor\jquery.js"></script>
    <script src="..\assets\js\vendor\fastclick.js"></script>
    <script src="..\assets\js\foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
  </html>